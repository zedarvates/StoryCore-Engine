// ============================================================================
// Character Manager Hook Tests
// ============================================================================
// Tests for the useCharacterManager hook, covering CRUD operations,
// validation, dependency checking, and relationship management.
//
// Requirements: 2.3, 2.5, 7.1, 7.4, 11.1, 11.2, 11.3
// ============================================================================

import { renderHook, act } from '@testing-library/react';
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { useCharacterManager, validateCharacter } from '../useCharacterManager';
import { useStore } from '../../store';
import type { Character } from '../../types/character';
import type { Story } from '../../types/story';

// Mock the store
vi.mock('../../store');

// Mock the event emitter
vi.mock('../../services/eventEmitter', () => ({
  eventEmitter: {
    emit: vi.fn(),
  },
}));

// Helper function to create a test character
function createTestCharacter(overrides: Partial<Character> = {}): Character {
  return {
    character_id: overrides.character_id || 'test-char-1',
    name: overrides.name || 'Test Character',
    creation_method: overrides.creation_method || 'manual',
    creation_timestamp: overrides.creation_timestamp || new Date().toISOString(),
    version: overrides.version || '1.0',
    visual_identity: {
      hair_color: 'brown',
      hair_style: 'short',
      hair_length: 'short',
      eye_color: 'blue',
      eye_shape: 'round',
      skin_tone: 'fair',
      facial_structure: 'oval',
      distinctive_features: [],
      age_range: '25-35',
      height: '5\'10"',
      build: 'athletic',
      posture: 'upright',
      clothing_style: 'casual',
      color_palette: ['blue', 'gray'],
      ...overrides.visual_identity,
    },
    personality: {
      traits: ['brave', 'loyal'],
      values: ['honor', 'justice'],
      fears: ['failure'],
      desires: ['success'],
      flaws: ['stubborn'],
      strengths: ['determined'],
      temperament: 'calm',
      communication_style: 'direct',
      ...overrides.personality,
    },
    background: {
      origin: 'City',
      occupation: 'Warrior',
      education: 'Military Academy',
      family: 'Noble family',
      significant_events: ['Battle of X'],
      current_situation: 'Active duty',
      ...overrides.background,
    },
    relationships: overrides.relationships || [],
    role: {
      archetype: 'Hero',
      narrative_function: 'Protagonist',
      character_arc: 'Growth',
      ...overrides.role,
    },
  };
}

// Helper function to create a test story
function createTestStory(overrides: Partial<Story> = {}): Story {
  return {
    id: overrides.id || 'test-story-1',
    title: overrides.title || 'Test Story',
    summary: overrides.summary || 'A test story',
    content: overrides.content || 'Story content',
    genre: overrides.genre || ['fantasy'],
    tone: overrides.tone || ['adventurous'],
    length: overrides.length || 'medium',
    worldId: overrides.worldId || 'test-world-1',
    charactersUsed: overrides.charactersUsed || [],
    locationsUsed: overrides.locationsUsed || [],
    autoGeneratedElements: overrides.autoGeneratedElements || [],
    createdAt: overrides.createdAt || new Date(),
    updatedAt: overrides.updatedAt || new Date(),
    version: overrides.version || 1,
  };
}

describe('validateCharacter', () => {
  describe('Requirement 11.1: Name validation', () => {
    it('should fail validation when name is empty', () => {
      const character: Partial<Character> = {
        name: '',
        role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        visual_identity: {
          ...createTestCharacter().visual_identity,
          age_range: '25-35',
        },
      };
      const result = validateCharacter(character);

      expect(result.valid).toBe(false);
      expect(result.errors.name).toContain('Character name is required');
    });

    it('should fail validation when name is only whitespace', () => {
      const character: Partial<Character> = {
        name: '   ',
        role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        visual_identity: {
          ...createTestCharacter().visual_identity,
          age_range: '25-35',
        },
      };
      const result = validateCharacter(character);

      expect(result.valid).toBe(false);
      expect(result.errors.name).toContain('Character name is required');
    });

    it('should pass validation when name is provided', () => {
      const character: Partial<Character> = {
        name: 'Valid Name',
        role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        visual_identity: {
          ...createTestCharacter().visual_identity,
          age_range: '25-35',
        },
      };
      const result = validateCharacter(character);

      expect(result.errors.name).toBeUndefined();
    });
  });

  describe('Requirement 11.2: Archetype validation', () => {
    it('should fail validation when archetype is empty', () => {
      const character: Partial<Character> = {
        name: 'Test Character',
        role: { archetype: '', narrative_function: '', character_arc: '' },
        visual_identity: {
          ...createTestCharacter().visual_identity,
          age_range: '25-35',
        },
      };
      const result = validateCharacter(character);

      expect(result.valid).toBe(false);
      expect(result.errors.archetype).toContain('Character archetype is required');
    });

    it('should fail validation when archetype is only whitespace', () => {
      const character: Partial<Character> = {
        name: 'Test Character',
        role: { archetype: '   ', narrative_function: '', character_arc: '' },
        visual_identity: {
          ...createTestCharacter().visual_identity,
          age_range: '25-35',
        },
      };
      const result = validateCharacter(character);

      expect(result.valid).toBe(false);
      expect(result.errors.archetype).toContain('Character archetype is required');
    });

    it('should pass validation when archetype is provided', () => {
      const character: Partial<Character> = {
        name: 'Test Character',
        role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        visual_identity: {
          ...createTestCharacter().visual_identity,
          age_range: '25-35',
        },
      };
      const result = validateCharacter(character);

      expect(result.errors.archetype).toBeUndefined();
    });
  });

  describe('Requirement 11.3: Age range validation', () => {
    it('should fail validation when age_range is empty', () => {
      const character: Partial<Character> = {
        name: 'Test Character',
        role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        visual_identity: {
          ...createTestCharacter().visual_identity,
          age_range: '',
        },
      };
      const result = validateCharacter(character);

      expect(result.valid).toBe(false);
      expect(result.errors.age_range).toContain('Character age range is required');
    });

    it('should fail validation when age_range is only whitespace', () => {
      const character: Partial<Character> = {
        name: 'Test Character',
        role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        visual_identity: {
          ...createTestCharacter().visual_identity,
          age_range: '   ',
        },
      };
      const result = validateCharacter(character);

      expect(result.valid).toBe(false);
      expect(result.errors.age_range).toContain('Character age range is required');
    });

    it('should pass validation when age_range is provided', () => {
      const character: Partial<Character> = {
        name: 'Test Character',
        role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        visual_identity: {
          ...createTestCharacter().visual_identity,
          age_range: '25-35',
        },
      };
      const result = validateCharacter(character);

      expect(result.errors.age_range).toBeUndefined();
    });
  });

  describe('Combined validation', () => {
    it('should pass validation when all required fields are provided', () => {
      const character: Partial<Character> = {
        name: 'Test Character',
        role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        visual_identity: {
          ...createTestCharacter().visual_identity,
          age_range: '25-35',
        },
      };
      const result = validateCharacter(character);

      expect(result.valid).toBe(true);
      expect(Object.keys(result.errors)).toHaveLength(0);
    });

    it('should fail validation with multiple errors when multiple fields are invalid', () => {
      const character: Partial<Character> = {
        name: '',
        role: { archetype: '', narrative_function: '', character_arc: '' },
        visual_identity: {
          ...createTestCharacter().visual_identity,
          age_range: '',
        },
      };
      const result = validateCharacter(character);

      expect(result.valid).toBe(false);
      expect(result.errors.name).toBeDefined();
      expect(result.errors.archetype).toBeDefined();
      expect(result.errors.age_range).toBeDefined();
    });
  });
});

describe('useCharacterManager', () => {
  let mockStore: any;

  beforeEach(() => {
    // Reset mock store before each test
    mockStore = {
      characters: [] as Character[],
      stories: [] as Story[],
      addCharacter: vi.fn((character: Character) => {
        mockStore.characters.push(character);
      }),
      updateCharacter: vi.fn((id: string, updates: Partial<Character>) => {
        const index = mockStore.characters.findIndex((c: Character) => c.character_id === id);
        if (index !== -1) {
          mockStore.characters[index] = { ...mockStore.characters[index], ...updates };
        }
      }),
      deleteCharacter: vi.fn((id: string) => {
        mockStore.characters = mockStore.characters.filter((c: Character) => c.character_id !== id);
      }),
      getCharacterById: vi.fn((id: string) => {
        return mockStore.characters.find((c: Character) => c.character_id === id);
      }),
      getAllCharacters: vi.fn(() => mockStore.characters),
      getAllStories: vi.fn(() => mockStore.stories),
    };

    (useStore as unknown as any).mockImplementation((selector: any) => {
      return selector(mockStore);
    });
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('createCharacter', () => {
    describe('Requirement 2.3: Validation before save', () => {
      it('should validate character data before creating', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const invalidCharacter = {
          name: '', // Invalid: empty name
          role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
          visual_identity: { age_range: '25-35' } as any,
        };

        await expect(
          act(async () => {
            await result.current.createCharacter(invalidCharacter);
          })
        ).rejects.toThrow('Character validation failed');

        expect(mockStore.addCharacter).not.toHaveBeenCalled();
      });

      it('should create character when validation passes', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const validCharacter = createTestCharacter();

        await act(async () => {
          await result.current.createCharacter(validCharacter);
        });

        expect(mockStore.addCharacter).toHaveBeenCalledWith(
          expect.objectContaining({
            name: validCharacter.name,
            role: expect.objectContaining({ archetype: validCharacter.role.archetype }),
          })
        );
      });
    });

    describe('Requirement 2.5: Dual persistence', () => {
      it('should add character to store', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character = createTestCharacter();

        await act(async () => {
          await result.current.createCharacter(character);
        });

        expect(mockStore.addCharacter).toHaveBeenCalled();
        expect(mockStore.characters).toHaveLength(1);
        expect(mockStore.characters[0].name).toBe(character.name);
      });

      it('should generate character ID if not provided', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const characterWithoutId = createTestCharacter();
        delete (characterWithoutId as any).character_id;

        await act(async () => {
          await result.current.createCharacter(characterWithoutId);
        });

        expect(mockStore.addCharacter).toHaveBeenCalled();
        expect(mockStore.characters[0].character_id).toBeDefined();
        expect(mockStore.characters[0].character_id).not.toBe('');
      });
    });
  });

  describe('updateCharacter', () => {
    describe('Requirement 2.3: Validation before save', () => {
      it('should validate character data before updating', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character = createTestCharacter();
        mockStore.characters.push(character);

        const invalidUpdates = {
          name: '', // Invalid: empty name
        };

        await expect(
          act(async () => {
            await result.current.updateCharacter(character.character_id, invalidUpdates);
          })
        ).rejects.toThrow('Character validation failed');

        expect(mockStore.updateCharacter).not.toHaveBeenCalled();
      });

      it('should update character when validation passes', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character = createTestCharacter();
        mockStore.characters.push(character);

        const validUpdates = {
          name: 'Updated Name',
        };

        await act(async () => {
          await result.current.updateCharacter(character.character_id, validUpdates);
        });

        expect(mockStore.updateCharacter).toHaveBeenCalledWith(
          character.character_id,
          validUpdates
        );
      });
    });

    describe('Requirement 2.5: Dual persistence', () => {
      it('should update character in store', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character = createTestCharacter();
        mockStore.characters.push(character);

        const updates = {
          name: 'Updated Name',
        };

        await act(async () => {
          await result.current.updateCharacter(character.character_id, updates);
        });

        expect(mockStore.updateCharacter).toHaveBeenCalled();
        expect(mockStore.characters[0].name).toBe('Updated Name');
      });

      it('should throw error if character does not exist', async () => {
        const { result } = renderHook(() => useCharacterManager());

        await expect(
          act(async () => {
            await result.current.updateCharacter('non-existent-id', { name: 'Test' });
          })
        ).rejects.toThrow('Character with ID "non-existent-id" not found');
      });
    });
  });

  describe('deleteCharacter', () => {
    describe('Requirement 7.1: Dependency check before deletion', () => {
      it('should check for story dependencies before deleting', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character = createTestCharacter();
        mockStore.characters.push(character);

        const story = createTestStory({
          charactersUsed: [
            {
              id: character.character_id,
              name: character.name,
              role: character.role.archetype,
            },
          ],
        });
        mockStore.stories.push(story);

        await expect(
          act(async () => {
            await result.current.deleteCharacter(character.character_id);
          })
        ).rejects.toThrow('Cannot delete character');

        expect(mockStore.deleteCharacter).not.toHaveBeenCalled();
      });

      it('should allow deletion with force option even with dependencies', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character = createTestCharacter();
        mockStore.characters.push(character);

        const story = createTestStory({
          charactersUsed: [
            {
              id: character.character_id,
              name: character.name,
              role: character.role.archetype,
            },
          ],
        });
        mockStore.stories.push(story);

        await act(async () => {
          await result.current.deleteCharacter(character.character_id, { force: true });
        });

        expect(mockStore.deleteCharacter).toHaveBeenCalledWith(character.character_id);
      });

      it('should allow deletion when no dependencies exist', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character = createTestCharacter();
        mockStore.characters.push(character);

        await act(async () => {
          await result.current.deleteCharacter(character.character_id);
        });

        expect(mockStore.deleteCharacter).toHaveBeenCalledWith(character.character_id);
      });
    });

    describe('Requirement 7.4: Deletion removes from all locations', () => {
      it('should remove character from store', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character = createTestCharacter();
        mockStore.characters.push(character);

        await act(async () => {
          await result.current.deleteCharacter(character.character_id);
        });

        expect(mockStore.deleteCharacter).toHaveBeenCalledWith(character.character_id);
        expect(mockStore.characters).toHaveLength(0);
      });

      it('should remove relationships with other characters', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Character 1' });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Character 2',
          relationships: [
            {
              character_id: 'char-1',
              character_name: 'Character 1',
              relationship_type: 'friend',
              description: 'Best friends',
              dynamic: 'Supportive',
            },
          ],
        });

        mockStore.characters.push(character1, character2);

        await act(async () => {
          await result.current.deleteCharacter('char-1');
        });

        expect(mockStore.deleteCharacter).toHaveBeenCalledWith('char-1');
        expect(mockStore.updateCharacter).toHaveBeenCalledWith(
          'char-2',
          expect.objectContaining({
            relationships: [],
          })
        );
      });

      it('should throw error if character does not exist', async () => {
        const { result } = renderHook(() => useCharacterManager());

        await expect(
          act(async () => {
            await result.current.deleteCharacter('non-existent-id');
          })
        ).rejects.toThrow('Character with ID "non-existent-id" not found');
      });
    });
  });

  describe('getCharacter', () => {
    it('should return character by ID', () => {
      const { result } = renderHook(() => useCharacterManager());

      const character = createTestCharacter();
      mockStore.characters.push(character);

      const retrieved = result.current.getCharacter(character.character_id);

      expect(retrieved).toEqual(character);
    });

    it('should return undefined if character does not exist', () => {
      const { result } = renderHook(() => useCharacterManager());

      const retrieved = result.current.getCharacter('non-existent-id');

      expect(retrieved).toBeUndefined();
    });
  });

  describe('getAllCharacters', () => {
    it('should return all characters', () => {
      const { result } = renderHook(() => useCharacterManager());

      const character1 = createTestCharacter({ character_id: 'char-1', name: 'Character 1' });
      const character2 = createTestCharacter({ character_id: 'char-2', name: 'Character 2' });
      mockStore.characters.push(character1, character2);

      const allCharacters = result.current.getAllCharacters();

      expect(allCharacters).toHaveLength(2);
      expect(allCharacters).toContainEqual(character1);
      expect(allCharacters).toContainEqual(character2);
    });

    it('should return empty array when no characters exist', () => {
      const { result } = renderHook(() => useCharacterManager());

      const allCharacters = result.current.getAllCharacters();

      expect(allCharacters).toEqual([]);
    });
  });

  describe('checkDependencies', () => {
    it('should find stories that use the character', () => {
      const { result } = renderHook(() => useCharacterManager());

      const character = createTestCharacter();
      mockStore.characters.push(character);

      const story1 = createTestStory({
        id: 'story-1',
        title: 'Story 1',
        charactersUsed: [
          {
            id: character.character_id,
            name: character.name,
            role: character.role.archetype,
          },
        ],
      });
      const story2 = createTestStory({
        id: 'story-2',
        title: 'Story 2',
        charactersUsed: [
          {
            id: character.character_id,
            name: character.name,
            role: character.role.archetype,
          },
        ],
      });
      mockStore.stories.push(story1, story2);

      const dependencies = result.current.checkDependencies(character.character_id);

      expect(dependencies.stories).toHaveLength(2);
      expect(dependencies.stories).toContainEqual(story1);
      expect(dependencies.stories).toContainEqual(story2);
    });

    it('should find characters with relationships to the character', () => {
      const { result } = renderHook(() => useCharacterManager());

      const character1 = createTestCharacter({ character_id: 'char-1', name: 'Character 1' });
      const character2 = createTestCharacter({
        character_id: 'char-2',
        name: 'Character 2',
        relationships: [
          {
            character_id: 'char-1',
            character_name: 'Character 1',
            relationship_type: 'friend',
            description: 'Best friends',
            dynamic: 'Supportive',
          },
        ],
      });
      const character3 = createTestCharacter({
        character_id: 'char-3',
        name: 'Character 3',
        relationships: [
          {
            character_id: 'char-1',
            character_name: 'Character 1',
            relationship_type: 'rival',
            description: 'Rivals',
            dynamic: 'Competitive',
          },
        ],
      });

      mockStore.characters.push(character1, character2, character3);

      const dependencies = result.current.checkDependencies('char-1');

      expect(dependencies.relationships).toHaveLength(2);
      expect(dependencies.relationships).toContainEqual(character2);
      expect(dependencies.relationships).toContainEqual(character3);
    });

    it('should return empty dependencies when character has no dependencies', () => {
      const { result } = renderHook(() => useCharacterManager());

      const character = createTestCharacter();
      mockStore.characters.push(character);

      const dependencies = result.current.checkDependencies(character.character_id);

      expect(dependencies.stories).toEqual([]);
      expect(dependencies.relationships).toEqual([]);
    });

    it('should return empty dependencies when character does not exist', () => {
      const { result } = renderHook(() => useCharacterManager());

      const dependencies = result.current.checkDependencies('non-existent-id');

      expect(dependencies.stories).toEqual([]);
      expect(dependencies.relationships).toEqual([]);
    });
  });

  describe('searchCharacters', () => {
    describe('Requirement 4.4, 9.2: Search by name, archetype, or traits', () => {
      it('should return all characters when query is empty', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Alice' });
        const character2 = createTestCharacter({ character_id: 'char-2', name: 'Bob' });
        mockStore.characters.push(character1, character2);

        const results = result.current.searchCharacters('');

        expect(results).toHaveLength(2);
        expect(results).toContainEqual(character1);
        expect(results).toContainEqual(character2);
      });

      it('should return all characters when query is only whitespace', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Alice' });
        const character2 = createTestCharacter({ character_id: 'char-2', name: 'Bob' });
        mockStore.characters.push(character1, character2);

        const results = result.current.searchCharacters('   ');

        expect(results).toHaveLength(2);
      });

      it('should search by name (case-insensitive)', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Alice Wonderland' });
        const character2 = createTestCharacter({ character_id: 'char-2', name: 'Bob Builder' });
        const character3 = createTestCharacter({ character_id: 'char-3', name: 'Charlie Brown' });
        mockStore.characters.push(character1, character2, character3);

        const results = result.current.searchCharacters('alice');

        expect(results).toHaveLength(1);
        expect(results[0]).toEqual(character1);
      });

      it('should search by name with partial match', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Alice Wonderland' });
        const character2 = createTestCharacter({ character_id: 'char-2', name: 'Bob Builder' });
        const character3 = createTestCharacter({ character_id: 'char-3', name: 'Charlie Brown' });
        mockStore.characters.push(character1, character2, character3);

        const results = result.current.searchCharacters('won');

        expect(results).toHaveLength(1);
        expect(results[0]).toEqual(character1);
      });

      it('should search by archetype (case-insensitive)', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Bob',
          role: { archetype: 'Villain', narrative_function: '', character_arc: '' },
        });
        const character3 = createTestCharacter({
          character_id: 'char-3',
          name: 'Charlie',
          role: { archetype: 'Mentor', narrative_function: '', character_arc: '' },
        });
        mockStore.characters.push(character1, character2, character3);

        const results = result.current.searchCharacters('HERO');

        expect(results).toHaveLength(1);
        expect(results[0]).toEqual(character1);
      });

      it('should search by archetype with partial match', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Bob',
          role: { archetype: 'Villain', narrative_function: '', character_arc: '' },
        });
        mockStore.characters.push(character1, character2);

        const results = result.current.searchCharacters('vill');

        expect(results).toHaveLength(1);
        expect(results[0]).toEqual(character2);
      });

      it('should search by traits (case-insensitive)', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          personality: {
            ...createTestCharacter().personality,
            traits: ['brave', 'loyal', 'determined'],
          },
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Bob',
          personality: {
            ...createTestCharacter().personality,
            traits: ['cunning', 'ambitious', 'ruthless'],
          },
        });
        mockStore.characters.push(character1, character2);

        const results = result.current.searchCharacters('BRAVE');

        expect(results).toHaveLength(1);
        expect(results[0]).toEqual(character1);
      });

      it('should search by traits with partial match', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          personality: {
            ...createTestCharacter().personality,
            traits: ['brave', 'loyal', 'determined'],
          },
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Bob',
          personality: {
            ...createTestCharacter().personality,
            traits: ['cunning', 'ambitious', 'ruthless'],
          },
        });
        mockStore.characters.push(character1, character2);

        const results = result.current.searchCharacters('ambi');

        expect(results).toHaveLength(1);
        expect(results[0]).toEqual(character2);
      });

      it('should return multiple matches when query matches multiple characters', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          personality: {
            ...createTestCharacter().personality,
            traits: ['brave', 'loyal'],
          },
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Bob',
          personality: {
            ...createTestCharacter().personality,
            traits: ['brave', 'strong'],
          },
        });
        const character3 = createTestCharacter({
          character_id: 'char-3',
          name: 'Charlie',
          personality: {
            ...createTestCharacter().personality,
            traits: ['cunning', 'smart'],
          },
        });
        mockStore.characters.push(character1, character2, character3);

        const results = result.current.searchCharacters('brave');

        expect(results).toHaveLength(2);
        expect(results).toContainEqual(character1);
        expect(results).toContainEqual(character2);
      });

      it('should return empty array when no matches found', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Alice' });
        const character2 = createTestCharacter({ character_id: 'char-2', name: 'Bob' });
        mockStore.characters.push(character1, character2);

        const results = result.current.searchCharacters('xyz');

        expect(results).toEqual([]);
      });

      it('should match across name, archetype, and traits', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Dark Knight',
          role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Alice',
          role: { archetype: 'Dark Mage', narrative_function: '', character_arc: '' },
        });
        const character3 = createTestCharacter({
          character_id: 'char-3',
          name: 'Bob',
          personality: {
            ...createTestCharacter().personality,
            traits: ['dark', 'mysterious'],
          },
        });
        mockStore.characters.push(character1, character2, character3);

        const results = result.current.searchCharacters('dark');

        expect(results).toHaveLength(3);
        expect(results).toContainEqual(character1);
        expect(results).toContainEqual(character2);
        expect(results).toContainEqual(character3);
      });
    });
  });

  describe('filterCharacters', () => {
    describe('Requirement 9.3, 9.4: Multi-criteria filtering', () => {
      it('should return all characters when no filters are provided', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Alice' });
        const character2 = createTestCharacter({ character_id: 'char-2', name: 'Bob' });
        mockStore.characters.push(character1, character2);

        const results = result.current.filterCharacters({});

        expect(results).toHaveLength(2);
        expect(results).toContainEqual(character1);
        expect(results).toContainEqual(character2);
      });

      it('should filter by archetype', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Bob',
          role: { archetype: 'Villain', narrative_function: '', character_arc: '' },
        });
        const character3 = createTestCharacter({
          character_id: 'char-3',
          name: 'Charlie',
          role: { archetype: 'Mentor', narrative_function: '', character_arc: '' },
        });
        mockStore.characters.push(character1, character2, character3);

        const results = result.current.filterCharacters({ archetype: ['Hero'] });

        expect(results).toHaveLength(1);
        expect(results[0]).toEqual(character1);
      });

      it('should filter by multiple archetypes', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Bob',
          role: { archetype: 'Villain', narrative_function: '', character_arc: '' },
        });
        const character3 = createTestCharacter({
          character_id: 'char-3',
          name: 'Charlie',
          role: { archetype: 'Mentor', narrative_function: '', character_arc: '' },
        });
        mockStore.characters.push(character1, character2, character3);

        const results = result.current.filterCharacters({ archetype: ['Hero', 'Villain'] });

        expect(results).toHaveLength(2);
        expect(results).toContainEqual(character1);
        expect(results).toContainEqual(character2);
      });

      it('should filter by archetype (case-insensitive)', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Bob',
          role: { archetype: 'Villain', narrative_function: '', character_arc: '' },
        });
        mockStore.characters.push(character1, character2);

        const results = result.current.filterCharacters({ archetype: ['HERO'] });

        expect(results).toHaveLength(1);
        expect(results[0]).toEqual(character1);
      });

      it('should filter by age range', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          visual_identity: {
            ...createTestCharacter().visual_identity,
            age_range: '18-25',
          },
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Bob',
          visual_identity: {
            ...createTestCharacter().visual_identity,
            age_range: '25-35',
          },
        });
        const character3 = createTestCharacter({
          character_id: 'char-3',
          name: 'Charlie',
          visual_identity: {
            ...createTestCharacter().visual_identity,
            age_range: '35-45',
          },
        });
        mockStore.characters.push(character1, character2, character3);

        const results = result.current.filterCharacters({ ageRange: ['25-35'] });

        expect(results).toHaveLength(1);
        expect(results[0]).toEqual(character2);
      });

      it('should filter by multiple age ranges', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          visual_identity: {
            ...createTestCharacter().visual_identity,
            age_range: '18-25',
          },
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Bob',
          visual_identity: {
            ...createTestCharacter().visual_identity,
            age_range: '25-35',
          },
        });
        const character3 = createTestCharacter({
          character_id: 'char-3',
          name: 'Charlie',
          visual_identity: {
            ...createTestCharacter().visual_identity,
            age_range: '35-45',
          },
        });
        mockStore.characters.push(character1, character2, character3);

        const results = result.current.filterCharacters({ ageRange: ['18-25', '35-45'] });

        expect(results).toHaveLength(2);
        expect(results).toContainEqual(character1);
        expect(results).toContainEqual(character3);
      });

      it('should filter by age range (case-insensitive)', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          visual_identity: {
            ...createTestCharacter().visual_identity,
            age_range: '25-35',
          },
        });
        mockStore.characters.push(character1);

        const results = result.current.filterCharacters({ ageRange: ['25-35'] });

        expect(results).toHaveLength(1);
        expect(results[0]).toEqual(character1);
      });

      it('should filter by creation method', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          creation_method: 'wizard',
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Bob',
          creation_method: 'auto_generated',
        });
        const character3 = createTestCharacter({
          character_id: 'char-3',
          name: 'Charlie',
          creation_method: 'manual',
        });
        mockStore.characters.push(character1, character2, character3);

        const results = result.current.filterCharacters({ creationMethod: ['wizard'] });

        expect(results).toHaveLength(1);
        expect(results[0]).toEqual(character1);
      });

      it('should filter by multiple creation methods', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          creation_method: 'wizard',
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Bob',
          creation_method: 'auto_generated',
        });
        const character3 = createTestCharacter({
          character_id: 'char-3',
          name: 'Charlie',
          creation_method: 'manual',
        });
        mockStore.characters.push(character1, character2, character3);

        const results = result.current.filterCharacters({
          creationMethod: ['wizard', 'manual'],
        });

        expect(results).toHaveLength(2);
        expect(results).toContainEqual(character1);
        expect(results).toContainEqual(character3);
      });

      it('should apply multiple filters (AND logic)', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
          visual_identity: {
            ...createTestCharacter().visual_identity,
            age_range: '25-35',
          },
          creation_method: 'wizard',
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Bob',
          role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
          visual_identity: {
            ...createTestCharacter().visual_identity,
            age_range: '35-45',
          },
          creation_method: 'wizard',
        });
        const character3 = createTestCharacter({
          character_id: 'char-3',
          name: 'Charlie',
          role: { archetype: 'Villain', narrative_function: '', character_arc: '' },
          visual_identity: {
            ...createTestCharacter().visual_identity,
            age_range: '25-35',
          },
          creation_method: 'manual',
        });
        mockStore.characters.push(character1, character2, character3);

        const results = result.current.filterCharacters({
          archetype: ['Hero'],
          ageRange: ['25-35'],
          creationMethod: ['wizard'],
        });

        expect(results).toHaveLength(1);
        expect(results[0]).toEqual(character1);
      });

      it('should return empty array when no characters match filters', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Alice',
          role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        });
        mockStore.characters.push(character1);

        const results = result.current.filterCharacters({ archetype: ['Villain'] });

        expect(results).toEqual([]);
      });

      it('should handle empty filter arrays', () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Alice' });
        const character2 = createTestCharacter({ character_id: 'char-2', name: 'Bob' });
        mockStore.characters.push(character1, character2);

        const results = result.current.filterCharacters({
          archetype: [],
          ageRange: [],
          creationMethod: [],
        });

        expect(results).toHaveLength(2);
        expect(results).toContainEqual(character1);
        expect(results).toContainEqual(character2);
      });
    });
  });

  describe('exportCharacter', () => {
    describe('Requirement 10.2: Export produces valid JSON', () => {
      it('should export character as JSON string', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character = createTestCharacter();
        mockStore.characters.push(character);

        const exported = await result.current.exportCharacter(character.character_id);

        // Should be valid JSON
        expect(() => JSON.parse(exported)).not.toThrow();

        // Should match original character
        const parsed = JSON.parse(exported);
        expect(parsed.character_id).toBe(character.character_id);
        expect(parsed.name).toBe(character.name);
        expect(parsed.role.archetype).toBe(character.role.archetype);
      });

      it('should throw error if character does not exist', async () => {
        const { result } = renderHook(() => useCharacterManager());

        await expect(
          result.current.exportCharacter('non-existent-id')
        ).rejects.toThrow('Character with ID "non-existent-id" not found');
      });

      it('should export all character fields', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character = createTestCharacter({
          name: 'Test Character',
          role: { archetype: 'Hero', narrative_function: 'Protagonist', character_arc: 'Growth' },
          visual_identity: {
            ...createTestCharacter().visual_identity,
            age_range: '25-35',
            hair_color: 'brown',
          },
          personality: {
            ...createTestCharacter().personality,
            traits: ['brave', 'loyal'],
          },
          relationships: [
            {
              character_id: 'char-2',
              character_name: 'Friend',
              relationship_type: 'friend',
              description: 'Best friends',
              dynamic: 'Supportive',
            },
          ],
        });
        mockStore.characters.push(character);

        const exported = await result.current.exportCharacter(character.character_id);
        const parsed = JSON.parse(exported);

        // Verify all major fields are present
        expect(parsed.name).toBe('Test Character');
        expect(parsed.role.archetype).toBe('Hero');
        expect(parsed.visual_identity.age_range).toBe('25-35');
        expect(parsed.visual_identity.hair_color).toBe('brown');
        expect(parsed.personality.traits).toEqual(['brave', 'loyal']);
        expect(parsed.relationships).toHaveLength(1);
        expect(parsed.relationships[0].character_id).toBe('char-2');
      });
    });
  });

  describe('importCharacter', () => {
    describe('Requirement 10.4: Import validation', () => {
      it('should import valid character JSON', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character = createTestCharacter();
        const jsonData = JSON.stringify(character);

        await act(async () => {
          await result.current.importCharacter(jsonData);
        });

        expect(mockStore.addCharacter).toHaveBeenCalled();
        expect(mockStore.characters).toHaveLength(1);
        expect(mockStore.characters[0].character_id).toBe(character.character_id);
      });

      it('should throw error for invalid JSON', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const invalidJson = '{ invalid json }';

        await expect(
          act(async () => {
            await result.current.importCharacter(invalidJson);
          })
        ).rejects.toThrow('Invalid JSON format');

        expect(mockStore.addCharacter).not.toHaveBeenCalled();
      });

      it('should throw error for JSON that does not match character schema', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const invalidCharacter = {
          name: '', // Invalid: empty name
          role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
        };
        const jsonData = JSON.stringify(invalidCharacter);

        await expect(
          act(async () => {
            await result.current.importCharacter(jsonData);
          })
        ).rejects.toThrow('Character validation failed');

        expect(mockStore.addCharacter).not.toHaveBeenCalled();
      });

      it('should validate all required fields', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const characterMissingFields = {
          character_id: 'test-char-1',
          name: 'Test',
          // Missing role and visual_identity
        };
        const jsonData = JSON.stringify(characterMissingFields);

        await expect(
          act(async () => {
            await result.current.importCharacter(jsonData);
          })
        ).rejects.toThrow('Character validation failed');

        expect(mockStore.addCharacter).not.toHaveBeenCalled();
      });
    });

    describe('Requirement 10.5: Import conflict handling', () => {
      it('should throw error when importing character with existing ID', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const existingCharacter = createTestCharacter({ character_id: 'char-1' });
        mockStore.characters.push(existingCharacter);

        const duplicateCharacter = createTestCharacter({ character_id: 'char-1', name: 'Different Name' });
        const jsonData = JSON.stringify(duplicateCharacter);

        await expect(
          act(async () => {
            await result.current.importCharacter(jsonData);
          })
        ).rejects.toThrow('Character with ID "char-1" already exists');

        // Should not add duplicate
        expect(mockStore.characters).toHaveLength(1);
        expect(mockStore.characters[0].name).toBe(existingCharacter.name);
      });

      it('should allow importing character with unique ID', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const existingCharacter = createTestCharacter({ character_id: 'char-1' });
        mockStore.characters.push(existingCharacter);

        const newCharacter = createTestCharacter({ character_id: 'char-2', name: 'New Character' });
        const jsonData = JSON.stringify(newCharacter);

        await act(async () => {
          await result.current.importCharacter(jsonData);
        });

        expect(mockStore.addCharacter).toHaveBeenCalled();
        expect(mockStore.characters).toHaveLength(2);
      });

      it('should provide helpful error message for ID conflicts', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const existingCharacter = createTestCharacter({ character_id: 'char-1' });
        mockStore.characters.push(existingCharacter);

        const duplicateCharacter = createTestCharacter({ character_id: 'char-1' });
        const jsonData = JSON.stringify(duplicateCharacter);

        await expect(
          act(async () => {
            await result.current.importCharacter(jsonData);
          })
        ).rejects.toThrow('Please rename or delete the existing character before importing');
      });
    });

    describe('Round-trip export/import', () => {
      it('should successfully export and re-import a character', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const originalCharacter = createTestCharacter({
          character_id: 'char-1',
          name: 'Original Character',
          role: { archetype: 'Hero', narrative_function: 'Protagonist', character_arc: 'Growth' },
        });
        mockStore.characters.push(originalCharacter);

        // Export
        const exported = await result.current.exportCharacter('char-1');

        // Clear store
        mockStore.characters = [];
        mockStore.addCharacter.mockClear();

        // Import
        await act(async () => {
          await result.current.importCharacter(exported);
        });

        // Verify character was imported correctly
        expect(mockStore.addCharacter).toHaveBeenCalled();
        expect(mockStore.characters).toHaveLength(1);
        expect(mockStore.characters[0].character_id).toBe('char-1');
        expect(mockStore.characters[0].name).toBe('Original Character');
        expect(mockStore.characters[0].role.archetype).toBe('Hero');
      });

      it('should preserve all character data in export/import', async () => {
        const { result } = renderHook(() => useCharacterManager());

        // Create the related character first
        const relatedCharacter = createTestCharacter({
          character_id: 'char-2',
          name: 'Friend',
        });
        mockStore.characters.push(relatedCharacter);

        const originalCharacter = createTestCharacter({
          character_id: 'char-1',
          name: 'Complex Character',
          personality: {
            ...createTestCharacter().personality,
            traits: ['brave', 'loyal', 'determined'],
            values: ['honor', 'justice'],
          },
          relationships: [
            {
              character_id: 'char-2',
              character_name: 'Friend',
              relationship_type: 'friend',
              description: 'Best friends',
              dynamic: 'Supportive',
            },
          ],
        });
        mockStore.characters.push(originalCharacter);

        // Export
        const exported = await result.current.exportCharacter('char-1');

        // Clear store but keep the related character
        mockStore.characters = [relatedCharacter];
        mockStore.addCharacter.mockClear();

        // Import
        await act(async () => {
          await result.current.importCharacter(exported);
        });

        // Verify all data was preserved
        const imported = mockStore.characters.find(c => c.character_id === 'char-1');
        expect(imported).toBeDefined();
        expect(imported!.personality.traits).toEqual(['brave', 'loyal', 'determined']);
        expect(imported!.personality.values).toEqual(['honor', 'justice']);
        expect(imported!.relationships).toHaveLength(1);
        expect(imported!.relationships[0].character_id).toBe('char-2');
      });
    });
  });

  // ============================================================================
  // Property-Based Tests
  // ============================================================================

  describe('Property-Based Tests', () => {
    describe('Property 5: Validation Before Save', () => {
      it('should validate all character modifications before persisting', async () => {
        const fc = await import('fast-check');
        const { result } = renderHook(() => useCharacterManager());

        // Generator for invalid character data (missing required fields)
        const invalidCharacterArbitrary = fc.default.record({
          name: fc.default.oneof(
            fc.default.constant(''),
            fc.default.constant('   '),
            fc.default.string({ minLength: 1, maxLength: 50 })
          ),
          role: fc.default.record({
            archetype: fc.default.oneof(
              fc.default.constant(''),
              fc.default.constant('   '),
              fc.default.string({ minLength: 1, maxLength: 30 })
            ),
            narrative_function: fc.default.string({ maxLength: 100 }),
            character_arc: fc.default.string({ maxLength: 100 }),
          }),
          visual_identity: fc.default.record({
            age_range: fc.default.oneof(
              fc.default.constant(''),
              fc.default.constant('   '),
              fc.default.string({ minLength: 1, maxLength: 20 })
            ),
            hair_color: fc.default.string({ maxLength: 30 }),
            hair_style: fc.default.string({ maxLength: 30 }),
            hair_length: fc.default.string({ maxLength: 30 }),
            eye_color: fc.default.string({ maxLength: 30 }),
            eye_shape: fc.default.string({ maxLength: 30 }),
            skin_tone: fc.default.string({ maxLength: 30 }),
            facial_structure: fc.default.string({ maxLength: 30 }),
            distinctive_features: fc.default.array(fc.default.string({ maxLength: 50 }), { maxLength: 5 }),
            height: fc.default.string({ maxLength: 20 }),
            build: fc.default.string({ maxLength: 30 }),
            posture: fc.default.string({ maxLength: 30 }),
            clothing_style: fc.default.string({ maxLength: 50 }),
            color_palette: fc.default.array(fc.default.string({ maxLength: 20 }), { maxLength: 5 }),
          }),
        });

        await fc.default.assert(
          fc.default.asyncProperty(
            invalidCharacterArbitrary,
            async (characterData) => {
              // Filter to only test cases where at least one required field is invalid
              const hasInvalidName = !characterData.name || characterData.name.trim() === '';
              const hasInvalidArchetype = !characterData.role.archetype || characterData.role.archetype.trim() === '';
              const hasInvalidAgeRange = !characterData.visual_identity.age_range || characterData.visual_identity.age_range.trim() === '';

              if (!hasInvalidName && !hasInvalidArchetype && !hasInvalidAgeRange) {
                // All required fields are valid, skip this test case
                return true;
              }

              // Reset store before each test
              mockStore.characters = [];
              mockStore.addCharacter.mockClear();

              // Attempt to create character with invalid data
              let errorThrown = false;
              try {
                await act(async () => {
                  await result.current.createCharacter(characterData as Partial<Character>);
                });
              } catch (error) {
                errorThrown = true;
              }

              // Verify that validation prevented the save
              expect(errorThrown).toBe(true);
              expect(mockStore.addCharacter).not.toHaveBeenCalled();
              expect(mockStore.characters).toHaveLength(0);

              return true;
            }
          ),
          { numRuns: 100 }
        );
      });

      it('should allow save when all required fields are valid', async () => {
        const fc = await import('fast-check');
        const { result } = renderHook(() => useCharacterManager());

        // Generator for valid character data
        const validCharacterArbitrary = fc.default.record({
          name: fc.default.string({ minLength: 1, maxLength: 50 }).filter(s => s.trim() !== ''),
          role: fc.default.record({
            archetype: fc.default.string({ minLength: 1, maxLength: 30 }).filter(s => s.trim() !== ''),
            narrative_function: fc.default.string({ maxLength: 100 }),
            character_arc: fc.default.string({ maxLength: 100 }),
          }),
          visual_identity: fc.default.record({
            age_range: fc.default.string({ minLength: 1, maxLength: 20 }).filter(s => s.trim() !== ''),
            hair_color: fc.default.string({ maxLength: 30 }),
            hair_style: fc.default.string({ maxLength: 30 }),
            hair_length: fc.default.string({ maxLength: 30 }),
            eye_color: fc.default.string({ maxLength: 30 }),
            eye_shape: fc.default.string({ maxLength: 30 }),
            skin_tone: fc.default.string({ maxLength: 30 }),
            facial_structure: fc.default.string({ maxLength: 30 }),
            distinctive_features: fc.default.array(fc.default.string({ maxLength: 50 }), { maxLength: 5 }),
            height: fc.default.string({ maxLength: 20 }),
            build: fc.default.string({ maxLength: 30 }),
            posture: fc.default.string({ maxLength: 30 }),
            clothing_style: fc.default.string({ maxLength: 50 }),
            color_palette: fc.default.array(fc.default.string({ maxLength: 20 }), { maxLength: 5 }),
          }),
        });

        await fc.default.assert(
          fc.default.asyncProperty(
            validCharacterArbitrary,
            async (characterData) => {
              // Reset store before each test
              mockStore.characters = [];
              mockStore.addCharacter.mockClear();

              // Attempt to create character with valid data
              let errorThrown = false;
              try {
                await act(async () => {
                  await result.current.createCharacter(characterData as Partial<Character>);
                });
              } catch (error) {
                errorThrown = true;
              }

              // Verify that validation allowed the save
              expect(errorThrown).toBe(false);
              expect(mockStore.addCharacter).toHaveBeenCalled();
              expect(mockStore.characters).toHaveLength(1);

              return true;
            }
          ),
          { numRuns: 100 }
        );
      });

      it('should validate updates before persisting', async () => {
        const fc = await import('fast-check');
        const { result } = renderHook(() => useCharacterManager());

        // Generator for invalid updates
        const invalidUpdateArbitrary = fc.default.record({
          name: fc.default.oneof(
            fc.default.constant(''),
            fc.default.constant('   ')
          ),
        });

        await fc.default.assert(
          fc.default.asyncProperty(
            invalidUpdateArbitrary,
            async (updates) => {
              // Create a valid character first
              const validCharacter = createTestCharacter();
              mockStore.characters = [validCharacter];
              mockStore.updateCharacter.mockClear();

              // Attempt to update with invalid data
              let errorThrown = false;
              try {
                await act(async () => {
                  await result.current.updateCharacter(validCharacter.character_id, updates);
                });
              } catch (error) {
                errorThrown = true;
              }

              // Verify that validation prevented the update
              expect(errorThrown).toBe(true);
              expect(mockStore.updateCharacter).not.toHaveBeenCalled();

              return true;
            }
          ),
          { numRuns: 100 }
        );
      });
    });

    describe('Property 7: Dual Persistence Consistency', () => {
      it('should save character to both store and localStorage on create', async () => {
        const fc = await import('fast-check');
        const { result } = renderHook(() => useCharacterManager());

        // Mock localStorage
        const localStorageMock: Record<string, string> = {};
        global.localStorage = {
          getItem: (key: string) => localStorageMock[key] || null,
          setItem: (key: string, value: string) => {
            localStorageMock[key] = value;
          },
          removeItem: (key: string) => {
            delete localStorageMock[key];
          },
          clear: () => {
            Object.keys(localStorageMock).forEach(key => delete localStorageMock[key]);
          },
          length: Object.keys(localStorageMock).length,
          key: (index: number) => Object.keys(localStorageMock)[index] || null,
        } as Storage;

        // Generator for valid character data
        const validCharacterArbitrary = fc.default.record({
          character_id: fc.default.uuid(),
          name: fc.default.string({ minLength: 1, maxLength: 50 }).filter(s => s.trim() !== ''),
          role: fc.default.record({
            archetype: fc.default.string({ minLength: 1, maxLength: 30 }).filter(s => s.trim() !== ''),
            narrative_function: fc.default.string({ maxLength: 100 }),
            character_arc: fc.default.string({ maxLength: 100 }),
          }),
          visual_identity: fc.default.record({
            age_range: fc.default.string({ minLength: 1, maxLength: 20 }).filter(s => s.trim() !== ''),
            hair_color: fc.default.string({ maxLength: 30 }),
            hair_style: fc.default.string({ maxLength: 30 }),
            hair_length: fc.default.string({ maxLength: 30 }),
            eye_color: fc.default.string({ maxLength: 30 }),
            eye_shape: fc.default.string({ maxLength: 30 }),
            skin_tone: fc.default.string({ maxLength: 30 }),
            facial_structure: fc.default.string({ maxLength: 30 }),
            distinctive_features: fc.default.array(fc.default.string({ maxLength: 50 }), { maxLength: 5 }),
            height: fc.default.string({ maxLength: 20 }),
            build: fc.default.string({ maxLength: 30 }),
            posture: fc.default.string({ maxLength: 30 }),
            clothing_style: fc.default.string({ maxLength: 50 }),
            color_palette: fc.default.array(fc.default.string({ maxLength: 20 }), { maxLength: 5 }),
          }),
        });

        await fc.default.assert(
          fc.default.asyncProperty(
            validCharacterArbitrary,
            async (characterData) => {
              // Reset state
              mockStore.characters = [];
              mockStore.addCharacter.mockClear();
              Object.keys(localStorageMock).forEach(key => delete localStorageMock[key]);

              // Create character
              await act(async () => {
                await result.current.createCharacter(characterData as Partial<Character>);
              });

              // Verify character is in store
              expect(mockStore.characters).toHaveLength(1);
              const storeCharacter = mockStore.characters[0];
              expect(storeCharacter.character_id).toBe(characterData.character_id);
              expect(storeCharacter.name).toBe(characterData.name);

              // Note: In the real implementation, localStorage persistence is handled by the store
              // In this test, we verify that the store action was called, which triggers persistence
              expect(mockStore.addCharacter).toHaveBeenCalledWith(
                expect.objectContaining({
                  character_id: characterData.character_id,
                  name: characterData.name,
                })
              );

              return true;
            }
          ),
          { numRuns: 100 }
        );
      });

      it('should update both store and localStorage on character update', async () => {
        const fc = await import('fast-check');
        const { result } = renderHook(() => useCharacterManager());

        // Mock localStorage
        const localStorageMock: Record<string, string> = {};
        global.localStorage = {
          getItem: (key: string) => localStorageMock[key] || null,
          setItem: (key: string, value: string) => {
            localStorageMock[key] = value;
          },
          removeItem: (key: string) => {
            delete localStorageMock[key];
          },
          clear: () => {
            Object.keys(localStorageMock).forEach(key => delete localStorageMock[key]);
          },
          length: Object.keys(localStorageMock).length,
          key: (index: number) => Object.keys(localStorageMock)[index] || null,
        } as Storage;

        // Generator for valid updates
        const validUpdateArbitrary = fc.default.record({
          name: fc.default.string({ minLength: 1, maxLength: 50 }).filter(s => s.trim() !== ''),
        });

        await fc.default.assert(
          fc.default.asyncProperty(
            validUpdateArbitrary,
            async (updates) => {
              // Create initial character
              const initialCharacter = createTestCharacter();
              mockStore.characters = [initialCharacter];
              mockStore.updateCharacter.mockClear();

              // Update character
              await act(async () => {
                await result.current.updateCharacter(initialCharacter.character_id, updates);
              });

              // Verify character is updated in store
              const updatedCharacter = mockStore.characters[0];
              expect(updatedCharacter.name).toBe(updates.name);

              // Verify store action was called (which triggers localStorage persistence)
              expect(mockStore.updateCharacter).toHaveBeenCalledWith(
                initialCharacter.character_id,
                expect.objectContaining(updates)
              );

              return true;
            }
          ),
          { numRuns: 100 }
        );
      });

      it('should maintain consistency between store and localStorage across operations', async () => {
        const fc = await import('fast-check');
        const { result } = renderHook(() => useCharacterManager());

        // Generator for a sequence of operations
        const operationArbitrary = fc.default.oneof(
          fc.default.record({
            type: fc.default.constant('create' as const),
            character: fc.default.record({
              name: fc.default.string({ minLength: 1, maxLength: 50 }).filter(s => s.trim() !== ''),
              role: fc.default.record({
                archetype: fc.default.string({ minLength: 1, maxLength: 30 }).filter(s => s.trim() !== ''),
                narrative_function: fc.default.string({ maxLength: 100 }),
                character_arc: fc.default.string({ maxLength: 100 }),
              }),
              visual_identity: fc.default.record({
                age_range: fc.default.string({ minLength: 1, maxLength: 20 }).filter(s => s.trim() !== ''),
                hair_color: fc.default.string({ maxLength: 30 }),
                hair_style: fc.default.string({ maxLength: 30 }),
                hair_length: fc.default.string({ maxLength: 30 }),
                eye_color: fc.default.string({ maxLength: 30 }),
                eye_shape: fc.default.string({ maxLength: 30 }),
                skin_tone: fc.default.string({ maxLength: 30 }),
                facial_structure: fc.default.string({ maxLength: 30 }),
                distinctive_features: fc.default.array(fc.default.string({ maxLength: 50 }), { maxLength: 5 }),
                height: fc.default.string({ maxLength: 20 }),
                build: fc.default.string({ maxLength: 30 }),
                posture: fc.default.string({ maxLength: 30 }),
                clothing_style: fc.default.string({ maxLength: 50 }),
                color_palette: fc.default.array(fc.default.string({ maxLength: 20 }), { maxLength: 5 }),
              }),
            }),
          }),
          fc.default.record({
            type: fc.default.constant('update' as const),
            name: fc.default.string({ minLength: 1, maxLength: 50 }).filter(s => s.trim() !== ''),
          })
        );

        await fc.default.assert(
          fc.default.asyncProperty(
            fc.default.array(operationArbitrary, { minLength: 1, maxLength: 5 }),
            async (operations) => {
              // Reset state
              mockStore.characters = [];
              mockStore.addCharacter.mockClear();
              mockStore.updateCharacter.mockClear();

              let createdCharacterId: string | null = null;
              let createCount = 0;
              let updateCount = 0;

              // Execute operations
              for (const operation of operations) {
                if (operation.type === 'create') {
                  await act(async () => {
                    const created = await result.current.createCharacter(operation.character as Partial<Character>);
                    createdCharacterId = created.character_id;
                    createCount++;
                  });
                } else if (operation.type === 'update' && createdCharacterId !== null) {
                  // Only update if we have created a character
                  await act(async () => {
                    await result.current.updateCharacter(createdCharacterId!, { name: operation.name });
                    updateCount++;
                  });
                }
              }

              // Skip validation if no create operations were performed
              if (createCount === 0) {
                return true;
              }

              // Verify consistency: all characters in store should have been persisted
              const storeCharacterCount = mockStore.characters.length;
              const createCallCount = mockStore.addCharacter.mock.calls.length;
              
              // At least one create operation should have been called
              expect(createCallCount).toBe(createCount);
              expect(storeCharacterCount).toBe(createCount);

              // If updates were performed, verify they were called
              if (updateCount > 0) {
                expect(mockStore.updateCharacter.mock.calls.length).toBe(updateCount);
              }

              return true;
            }
          ),
          { numRuns: 50 } // Reduced runs due to complexity
        );
      });
    });
  });

  describe('Relationship Management', () => {
    describe('Requirement 6.1, 6.2, 6.3: Bidirectional relationship management', () => {
      it('should add bidirectional relationship between two characters', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Character 1' });
        const character2 = createTestCharacter({ character_id: 'char-2', name: 'Character 2' });
        mockStore.characters.push(character1, character2);

        await act(async () => {
          await result.current.addRelationship('char-1', 'char-2', {
            relationship_type: 'mentor',
            description: 'Teaches advanced magic',
            dynamic: 'Respectful and supportive',
          });
        });

        // Verify both characters were updated
        expect(mockStore.updateCharacter).toHaveBeenCalledTimes(2);
        
        // Verify forward relationship was added
        expect(mockStore.updateCharacter).toHaveBeenCalledWith(
          'char-1',
          expect.objectContaining({
            relationships: expect.arrayContaining([
              expect.objectContaining({
                character_id: 'char-2',
                relationship_type: 'mentor',
              }),
            ]),
          })
        );

        // Verify inverse relationship was added
        expect(mockStore.updateCharacter).toHaveBeenCalledWith(
          'char-2',
          expect.objectContaining({
            relationships: expect.arrayContaining([
              expect.objectContaining({
                character_id: 'char-1',
                relationship_type: 'student',
              }),
            ]),
          })
        );
      });

      it('should update bidirectional relationship between two characters', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Character 1',
          relationships: [
            {
              character_id: 'char-2',
              character_name: 'Character 2',
              relationship_type: 'mentor',
              description: 'Teaches magic',
              dynamic: 'Supportive',
            },
          ],
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Character 2',
          relationships: [
            {
              character_id: 'char-1',
              character_name: 'Character 1',
              relationship_type: 'student',
              description: 'Teaches magic',
              dynamic: 'Supportive',
            },
          ],
        });
        mockStore.characters.push(character1, character2);

        await act(async () => {
          await result.current.updateRelationship('char-1', 'char-2', {
            description: 'Teaches advanced and dark magic',
            dynamic: 'Becoming tense',
          });
        });

        // Verify both characters were updated
        expect(mockStore.updateCharacter).toHaveBeenCalledTimes(2);
        
        // Verify both relationships were updated with new description and dynamic
        expect(mockStore.updateCharacter).toHaveBeenCalledWith(
          'char-1',
          expect.objectContaining({
            relationships: expect.arrayContaining([
              expect.objectContaining({
                character_id: 'char-2',
                description: 'Teaches advanced and dark magic',
                dynamic: 'Becoming tense',
              }),
            ]),
          })
        );

        expect(mockStore.updateCharacter).toHaveBeenCalledWith(
          'char-2',
          expect.objectContaining({
            relationships: expect.arrayContaining([
              expect.objectContaining({
                character_id: 'char-1',
                description: 'Teaches advanced and dark magic',
                dynamic: 'Becoming tense',
              }),
            ]),
          })
        );
      });

      it('should remove bidirectional relationship between two characters', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({
          character_id: 'char-1',
          name: 'Character 1',
          relationships: [
            {
              character_id: 'char-2',
              character_name: 'Character 2',
              relationship_type: 'friend',
              description: 'Best friends',
              dynamic: 'Supportive',
            },
          ],
        });
        const character2 = createTestCharacter({
          character_id: 'char-2',
          name: 'Character 2',
          relationships: [
            {
              character_id: 'char-1',
              character_name: 'Character 1',
              relationship_type: 'friend',
              description: 'Best friends',
              dynamic: 'Supportive',
            },
          ],
        });
        mockStore.characters.push(character1, character2);

        await act(async () => {
          await result.current.removeRelationship('char-1', 'char-2');
        });

        // Verify both characters were updated
        expect(mockStore.updateCharacter).toHaveBeenCalledTimes(2);
        
        // Verify relationships were removed from both characters
        expect(mockStore.updateCharacter).toHaveBeenCalledWith(
          'char-1',
          expect.objectContaining({
            relationships: [],
          })
        );

        expect(mockStore.updateCharacter).toHaveBeenCalledWith(
          'char-2',
          expect.objectContaining({
            relationships: [],
          })
        );
      });

      it('should throw error when adding relationship to non-existent character', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Character 1' });
        mockStore.characters.push(character1);

        await expect(
          act(async () => {
            await result.current.addRelationship('char-1', 'non-existent', {
              relationship_type: 'friend',
              description: 'Friends',
              dynamic: 'Supportive',
            });
          })
        ).rejects.toThrow('Target character with ID "non-existent" not found');

        expect(mockStore.updateCharacter).not.toHaveBeenCalled();
      });

      it('should throw error when updating non-existent relationship', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Character 1' });
        const character2 = createTestCharacter({ character_id: 'char-2', name: 'Character 2' });
        mockStore.characters.push(character1, character2);

        await expect(
          act(async () => {
            await result.current.updateRelationship('char-1', 'char-2', {
              description: 'Updated',
            });
          })
        ).rejects.toThrow('No relationship found');

        expect(mockStore.updateCharacter).not.toHaveBeenCalled();
      });

      it('should throw error when removing non-existent relationship', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Character 1' });
        const character2 = createTestCharacter({ character_id: 'char-2', name: 'Character 2' });
        mockStore.characters.push(character1, character2);

        await expect(
          act(async () => {
            await result.current.removeRelationship('char-1', 'char-2');
          })
        ).rejects.toThrow('No relationship found');

        expect(mockStore.updateCharacter).not.toHaveBeenCalled();
      });
    });

    describe('Requirement 11.4: Relationship reference validation', () => {
      it('should validate relationship references when creating character', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Character 1' });
        mockStore.characters.push(character1);

        const characterWithInvalidRelationship = createTestCharacter({
          character_id: 'char-2',
          name: 'Character 2',
          relationships: [
            {
              character_id: 'non-existent-char',
              character_name: 'Non-existent',
              relationship_type: 'friend',
              description: 'Friends',
              dynamic: 'Supportive',
            },
          ],
        });

        await expect(
          act(async () => {
            await result.current.createCharacter(characterWithInvalidRelationship);
          })
        ).rejects.toThrow('Character validation failed');

        expect(mockStore.addCharacter).not.toHaveBeenCalled();
      });

      it('should validate relationship references when updating character', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Character 1' });
        const character2 = createTestCharacter({ character_id: 'char-2', name: 'Character 2' });
        mockStore.characters.push(character1, character2);

        const invalidUpdates = {
          relationships: [
            {
              character_id: 'non-existent-char',
              character_name: 'Non-existent',
              relationship_type: 'friend',
              description: 'Friends',
              dynamic: 'Supportive',
            },
          ],
        };

        await expect(
          act(async () => {
            await result.current.updateCharacter('char-1', invalidUpdates);
          })
        ).rejects.toThrow('Character validation failed');

        expect(mockStore.updateCharacter).not.toHaveBeenCalled();
      });

      it('should allow valid relationship references when creating character', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Character 1' });
        mockStore.characters.push(character1);

        const characterWithValidRelationship = createTestCharacter({
          character_id: 'char-2',
          name: 'Character 2',
          relationships: [
            {
              character_id: 'char-1',
              character_name: 'Character 1',
              relationship_type: 'friend',
              description: 'Friends',
              dynamic: 'Supportive',
            },
          ],
        });

        await act(async () => {
          await result.current.createCharacter(characterWithValidRelationship);
        });

        expect(mockStore.addCharacter).toHaveBeenCalled();
      });

      it('should allow valid relationship references when updating character', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const character1 = createTestCharacter({ character_id: 'char-1', name: 'Character 1' });
        const character2 = createTestCharacter({ character_id: 'char-2', name: 'Character 2' });
        mockStore.characters.push(character1, character2);

        const validUpdates = {
          relationships: [
            {
              character_id: 'char-2',
              character_name: 'Character 2',
              relationship_type: 'friend',
              description: 'Friends',
              dynamic: 'Supportive',
            },
          ],
        };

        await act(async () => {
          await result.current.updateCharacter('char-1', validUpdates);
        });

        expect(mockStore.updateCharacter).toHaveBeenCalled();
      });

      it('should allow empty relationships array', async () => {
        const { result } = renderHook(() => useCharacterManager());

        const characterWithNoRelationships = createTestCharacter({
          character_id: 'char-1',
          name: 'Character 1',
          relationships: [],
        });

        await act(async () => {
          await result.current.createCharacter(characterWithNoRelationships);
        });

        expect(mockStore.addCharacter).toHaveBeenCalled();
      });
    });

    describe('Property 27: Required Field Validation', () => {
      it('should fail validation when name is empty or whitespace', async () => {
        const fc = await import('fast-check');

        // Generator for invalid names (empty or whitespace)
        const invalidNameArbitrary = fc.default.oneof(
          fc.default.constant(''),
          fc.default.constant('   '),
          fc.default.constant('\t'),
          fc.default.constant('\n'),
          fc.default.string({ maxLength: 10 }).filter(s => s.trim() === '')
        );

        await fc.default.assert(
          fc.default.property(
            invalidNameArbitrary,
            (invalidName) => {
              const character: Partial<Character> = {
                name: invalidName,
                role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
                visual_identity: {
                  ...createTestCharacter().visual_identity,
                  age_range: '25-35',
                },
              };

              const result = validateCharacter(character);

              // Validation should fail
              expect(result.valid).toBe(false);
              // Should have error for name field
              expect(result.errors.name).toBeDefined();
              expect(result.errors.name).toContain('Character name is required');

              return true;
            }
          ),
          { numRuns: 100 }
        );
      });

      it('should fail validation when archetype is empty or whitespace', async () => {
        const fc = await import('fast-check');

        // Generator for invalid archetypes (empty or whitespace)
        const invalidArchetypeArbitrary = fc.default.oneof(
          fc.default.constant(''),
          fc.default.constant('   '),
          fc.default.constant('\t'),
          fc.default.constant('\n'),
          fc.default.string({ maxLength: 10 }).filter(s => s.trim() === '')
        );

        await fc.default.assert(
          fc.default.property(
            invalidArchetypeArbitrary,
            (invalidArchetype) => {
              const character: Partial<Character> = {
                name: 'Test Character',
                role: { archetype: invalidArchetype, narrative_function: '', character_arc: '' },
                visual_identity: {
                  ...createTestCharacter().visual_identity,
                  age_range: '25-35',
                },
              };

              const result = validateCharacter(character);

              // Validation should fail
              expect(result.valid).toBe(false);
              // Should have error for archetype field
              expect(result.errors.archetype).toBeDefined();
              expect(result.errors.archetype).toContain('Character archetype is required');

              return true;
            }
          ),
          { numRuns: 100 }
        );
      });

      it('should fail validation when age_range is empty or whitespace', async () => {
        const fc = await import('fast-check');

        // Generator for invalid age ranges (empty or whitespace)
        const invalidAgeRangeArbitrary = fc.default.oneof(
          fc.default.constant(''),
          fc.default.constant('   '),
          fc.default.constant('\t'),
          fc.default.constant('\n'),
          fc.default.string({ maxLength: 10 }).filter(s => s.trim() === '')
        );

        await fc.default.assert(
          fc.default.property(
            invalidAgeRangeArbitrary,
            (invalidAgeRange) => {
              const character: Partial<Character> = {
                name: 'Test Character',
                role: { archetype: 'Hero', narrative_function: '', character_arc: '' },
                visual_identity: {
                  ...createTestCharacter().visual_identity,
                  age_range: invalidAgeRange,
                },
              };

              const result = validateCharacter(character);

              // Validation should fail
              expect(result.valid).toBe(false);
              // Should have error for age_range field
              expect(result.errors.age_range).toBeDefined();
              expect(result.errors.age_range).toContain('Character age range is required');

              return true;
            }
          ),
          { numRuns: 100 }
        );
      });

      it('should fail validation with multiple errors when multiple required fields are invalid', async () => {
        const fc = await import('fast-check');

        // Generator for combinations of invalid required fields
        const invalidFieldsArbitrary = fc.default.record({
          name: fc.default.oneof(
            fc.default.constant(''),
            fc.default.constant('   '),
            fc.default.string({ minLength: 1, maxLength: 50 }).filter(s => s.trim() !== '')
          ),
          archetype: fc.default.oneof(
            fc.default.constant(''),
            fc.default.constant('   '),
            fc.default.string({ minLength: 1, maxLength: 30 }).filter(s => s.trim() !== '')
          ),
          age_range: fc.default.oneof(
            fc.default.constant(''),
            fc.default.constant('   '),
            fc.default.string({ minLength: 1, maxLength: 20 }).filter(s => s.trim() !== '')
          ),
        });

        await fc.default.assert(
          fc.default.property(
            invalidFieldsArbitrary,
            (fields) => {
              const character: Partial<Character> = {
                name: fields.name,
                role: { archetype: fields.archetype, narrative_function: '', character_arc: '' },
                visual_identity: {
                  ...createTestCharacter().visual_identity,
                  age_range: fields.age_range,
                },
              };

              const result = validateCharacter(character);

              // Count how many fields are invalid
              const isNameInvalid = !fields.name || fields.name.trim() === '';
              const isArchetypeInvalid = !fields.archetype || fields.archetype.trim() === '';
              const isAgeRangeInvalid = !fields.age_range || fields.age_range.trim() === '';
              const invalidCount = [isNameInvalid, isArchetypeInvalid, isAgeRangeInvalid].filter(Boolean).length;

              if (invalidCount > 0) {
                // Validation should fail
                expect(result.valid).toBe(false);

                // Check that each invalid field has an error
                if (isNameInvalid) {
                  expect(result.errors.name).toBeDefined();
                  expect(result.errors.name).toContain('Character name is required');
                }
                if (isArchetypeInvalid) {
                  expect(result.errors.archetype).toBeDefined();
                  expect(result.errors.archetype).toContain('Character archetype is required');
                }
                if (isAgeRangeInvalid) {
                  expect(result.errors.age_range).toBeDefined();
                  expect(result.errors.age_range).toContain('Character age range is required');
                }

                // Verify error count matches invalid field count
                expect(Object.keys(result.errors).length).toBe(invalidCount);
              } else {
                // All fields are valid, validation should pass
                expect(result.valid).toBe(true);
                expect(Object.keys(result.errors).length).toBe(0);
              }

              return true;
            }
          ),
          { numRuns: 100 }
        );
      });

      it('should pass validation when all required fields are non-empty', async () => {
        const fc = await import('fast-check');

        // Generator for valid required fields
        const validFieldsArbitrary = fc.default.record({
          name: fc.default.string({ minLength: 1, maxLength: 50 }).filter(s => s.trim() !== ''),
          archetype: fc.default.string({ minLength: 1, maxLength: 30 }).filter(s => s.trim() !== ''),
          age_range: fc.default.string({ minLength: 1, maxLength: 20 }).filter(s => s.trim() !== ''),
        });

        await fc.default.assert(
          fc.default.property(
            validFieldsArbitrary,
            (fields) => {
              const character: Partial<Character> = {
                name: fields.name,
                role: { archetype: fields.archetype, narrative_function: '', character_arc: '' },
                visual_identity: {
                  ...createTestCharacter().visual_identity,
                  age_range: fields.age_range,
                },
              };

              const result = validateCharacter(character);

              // Validation should pass
              expect(result.valid).toBe(true);
              // Should have no errors
              expect(Object.keys(result.errors).length).toBe(0);
              // Specifically, no errors for required fields
              expect(result.errors.name).toBeUndefined();
              expect(result.errors.archetype).toBeUndefined();
              expect(result.errors.age_range).toBeUndefined();

              return true;
            }
          ),
          { numRuns: 100 }
        );
      });
    });
  });
});
