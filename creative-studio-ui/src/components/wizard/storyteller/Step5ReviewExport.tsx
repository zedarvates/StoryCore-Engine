import React, { useState, useEffect } from 'react';
import { useWizard } from '@/contexts/WizardContext';
import { WizardFormLayout, FormField } from '../WizardFormLayout';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Checkbox } from '@/components/ui/checkbox';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Download, CheckCircle, AlertCircle, History, RotateCcw, Wand2, Image, Music, Video, Copy } from 'lucide-react';
import type { ExportOptions } from '@/types/story';
import { exportStory } from '@/services/storyExportService';
import { useStore } from '@/store';
import { useLLMGeneration } from '@/hooks/useLLMGeneration';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';

// ============================================================================
// Wizard Form Data Interface
// ============================================================================

interface StoryWizardFormData {
  title?: string;
  genre?: string[];
  tone?: string[];
  length?: 'short' | 'medium' | 'long';
  selectedCharacters?: Array<{ id: string; name: string; role: string }>;
  selectedLocations?: Array<{ id: string; name: string; significance: string }>;
  generatedContent?: string;
  generatedSummary?: string;
  parts?: any[];
  assetPrompts?: any;
}

// ============================================================================
// Step 5: Review and Export
// ============================================================================

export function Step5ReviewExport() {
  const { formData, updateFormData } = useWizard<StoryWizardFormData>();
  const { getVersionsByStoryId, loadVersion } = useStore();
  const [isAIProcessing, setIsAIProcessing] = useState(false);

  const [isExporting, setIsExporting] = useState(false);
  const [exportSuccess, setExportSuccess] = useState(false);
  const [exportError, setExportError] = useState<string | null>(null);
  const [exportedFilePath, setExportedFilePath] = useState<string | null>(null);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [storyId] = useState(() => crypto.randomUUID()); // Generate stable ID for this story
  const [versions, setVersions] = useState<Array<{ id: string; versionNumber: number; createdAt: Date; changes: string }>>([]);
  const [selectedVersionId, setSelectedVersionId] = useState<string | null>(null);

  const [assetPrompts, setAssetPrompts] = useState<{
    image?: string;
    audio?: string;
    video?: string;
  }>({});

  // Load versions when component mounts or storyId changes
  useEffect(() => {
    const loadedVersions = getVersionsByStoryId(storyId);
    setVersions(loadedVersions);
  }, [storyId, getVersionsByStoryId]);

  const [exportOptions, setExportOptions] = useState<ExportOptions>({
    format: 'md',
    includeMetadata: true,
    includeSummary: true,
    filename: formData.title || 'story',
  });

  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    updateFormData({ generatedContent: e.target.value });
    setHasUnsavedChanges(true);
  };

  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    updateFormData({ title: e.target.value });
    setExportOptions({ ...exportOptions, filename: e.target.value || 'story' });
  };

  const handleLoadVersion = (versionId: string) => {
    if (versionId === 'current') {
      setSelectedVersionId(null);
      return;
    }

    loadVersion(versionId);
    setSelectedVersionId(versionId);

    // Reload versions to get updated data
    const loadedVersions = getVersionsByStoryId(storyId);
    setVersions(loadedVersions);
  };

  const handleExport = async () => {
    setIsExporting(true);
    setExportSuccess(false);
    setExportError(null);

    try {
      // Build story object for export
      const story = {
        id: crypto.randomUUID(),
        title: formData.title || 'Untitled Story',
        content: formData.generatedContent || '',
        summary: formData.generatedSummary || '',
        genre: formData.genre || [],
        tone: formData.tone || [],
        length: formData.length || 'medium',
        charactersUsed: formData.selectedCharacters || [],
        locationsUsed: formData.selectedLocations || [],
        autoGeneratedElements: [],
        assetPrompts: assetPrompts, // Include generated asset prompts
        createdAt: new Date(),
        updatedAt: new Date(),
        version: 1,
      };

      // Export story
      const filePath = await exportStory(story, exportOptions);

      setExportSuccess(true);
      setExportedFilePath(filePath);
      setHasUnsavedChanges(false);
    } catch (error) {
      console.error('Export failed:', error);
      setExportError(error instanceof Error ? error.message : 'Failed to export story');
    } finally {
      setIsExporting(false);
    }
  };

  const generateContent = async (prompt: string, type: 'image' | 'audio' | 'video'): Promise<string | null> => {
    setIsAIProcessing(true);
    try {
      const { llmConfigService } = await import('@/services/llmConfigService');
      const service = llmConfigService.getService();

      if (!service) {
        return null;
      }

      let systemPrompt = '';
      if (type === 'image') systemPrompt = 'You are an expert AI art prompt engineer.';
      if (type === 'audio') systemPrompt = 'You are an expert sound designer and music supervisor.';
      if (type === 'video') systemPrompt = 'You are an expert video director and cinematographer.';

      const response = await service.generateCompletion({
        prompt,
        systemPrompt,
        temperature: 0.7
      });

      if (response.success && response.data) {
        return response.data.content;
      }
      return null;
    } catch (error) {
      console.error(`Failed to generate ${type} prompts`, error);
      return null;
    } finally {
      setIsAIProcessing(false);
    }
  };

  const generateAssetPrompts = async (type: 'image' | 'audio' | 'video') => {
    if (!formData.generatedSummary && !formData.generatedContent) return;

    const context = formData.generatedSummary || formData.generatedContent?.substring(0, 1000) || '';

    let prompt = '';

    switch (type) {
      case 'image':
        prompt = `Based on this story summary, generate 3 detailed Midjourney/DALL-E image prompts for the main scenes/characters: \n\n${context}`;
        break;
      case 'audio':
        prompt = `Based on this story summary, describe the audio atmosphere, creating a prompt for music generation and a list of key sound effects: \n\n${context}`;
        break;
      case 'video':
        prompt = `Based on this story summary, create a prompt for an AI video generator (like Sora/Runway) to create a cinematic trailer for this story: \n\n${context}`;
        break;
    }

    const result = await generateContent(prompt, type);
    if (result) {
      setAssetPrompts(prev => ({ ...prev, [type]: result }));
    }
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
  };

  const wordCount = formData.generatedContent?.split(' ').length || 0;
  const characterCount = formData.generatedContent?.length || 0;

  return (
    <WizardFormLayout
      title="Review and Export"
      description="Review your story and export it to a file"
    >
      {/* Story Title */}
      <FormField
        label="Story Title"
        name="title"
        helpText="Edit the title if needed"
      >
        <Input
          id="title"
          value={formData.title || ''}
          onChange={handleTitleChange}
          placeholder="Enter story title"
        />
      </FormField>

      {/* Version History */}
      {versions.length > 0 && (
        <div className="space-y-2">
          <Label htmlFor="version-selector" className="flex items-center gap-2">
            <History className="w-4 h-4" />
            Version History
          </Label>
          <div className="flex gap-2">
            <Select
              value={selectedVersionId || 'current'}
              onValueChange={handleLoadVersion}
            >
              <SelectTrigger id="version-selector" className="flex-1">
                <SelectValue placeholder="Select a version" />
              </SelectTrigger>
              <SelectContent className="z-[9999]">
                <SelectItem value="current">
                  Current Version (Latest)
                </SelectItem>
                {versions.map((version) => (
                  <SelectItem key={version.id} value={version.id}>
                    Version {version.versionNumber} - {new Date(version.createdAt).toLocaleString()}
                    {version.changes && ` - ${version.changes}`}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            {selectedVersionId && (
              <Button
                variant="outline"
                size="icon"
                onClick={() => handleLoadVersion('current')}
                title="Return to current version"
              >
                <RotateCcw className="w-4 h-4" />
              </Button>
            )}
          </div>
          {selectedVersionId && (
            <p className="text-xs text-amber-600 flex items-center gap-1">
              <AlertCircle className="w-3 h-3" />
              Viewing historical version. Click the reset button to return to current.
            </p>
          )}
        </div>
      )}

      {/* Summary Display */}
      <div className="space-y-2">
        <Label>Summary</Label>
        <div className="p-4 rounded-lg bg-blue-50 dark:bg-blue-950/20 border border-blue-200 dark:border-blue-800">
          <p className="text-sm text-muted-foreground">
            {formData.generatedSummary || 'No summary available'}
          </p>
        </div>
      </div>

      {/* Story Content (Editable) */}
      <div className="space-y-2">
        <div className="flex items-center justify-between">
          <Label htmlFor="story-content">Story Content</Label>
          {hasUnsavedChanges && (
            <span className="text-xs text-amber-600 flex items-center gap-1">
              <AlertCircle className="w-3 h-3" />
              Unsaved changes
            </span>
          )}
        </div>
        <Textarea
          id="story-content"
          value={formData.generatedContent || ''}
          onChange={handleContentChange}
          rows={15}
          className="font-mono text-sm"
          placeholder="Story content will appear here..."
        />
        <div className="flex gap-4 text-xs text-muted-foreground">
          <span>ðŸ“– {wordCount} words</span>
          <span>ðŸ”¤ {characterCount} characters</span>
        </div>
      </div>

      {/* Metadata Display */}
      <div className="space-y-2">
        <Label>Story Metadata</Label>
        <div className="p-4 rounded-lg bg-gray-50 dark:bg-gray-900 border border-gray-200 dark:border-gray-800 space-y-2 text-sm">
          <div className="flex gap-2">
            <span className="font-medium">Genre:</span>
            <span className="text-muted-foreground">{formData.genre?.join(', ') || 'None'}</span>
          </div>
          <div className="flex gap-2">
            <span className="font-medium">Tone:</span>
            <span className="text-muted-foreground">{formData.tone?.join(', ') || 'None'}</span>
          </div>
          <div className="flex gap-2">
            <span className="font-medium">Length:</span>
            <span className="text-muted-foreground">{formData.length || 'medium'}</span>
          </div>
          <div className="flex gap-2">
            <span className="font-medium">Characters:</span>
            <span className="text-muted-foreground">
              {formData.selectedCharacters?.length || 0} selected
            </span>
          </div>
          <div className="flex gap-2">
            <span className="font-medium">Locations:</span>
            <span className="text-muted-foreground">
              {formData.selectedLocations?.length || 0} selected
            </span>
          </div>
        </div>
      </div>

      {/* Story Structure Info */}
      {formData.parts && formData.parts.length > 0 && (
        <div className="space-y-2">
          <Label>LLM-Optimized File Structure</Label>
          <div className="p-4 rounded-lg bg-green-50 dark:bg-green-950/20 border border-green-200 dark:border-green-800">
            <p className="text-sm text-green-900 dark:text-green-100 mb-2">
              Story will be saved as separate .md files for optimal LLM processing:
            </p>
            <div className="font-mono text-xs space-y-1 text-green-800 dark:text-green-200">
              <div>story/</div>
              <div className="pl-4">â”œâ”€â”€ story-index.md <span className="text-muted-foreground"># Index & metadata</span></div>
              <div className="pl-4">â”œâ”€â”€ story-intro.md <span className="text-muted-foreground"># Introduction</span></div>
              {formData.parts.filter((p: any) => p.type === 'chapter').map((part: any, i: number) => (
                <div key={part.id} className="pl-4">â”œâ”€â”€ story-chapter-{String(i + 1).padStart(2, '0')}.md <span className="text-muted-foreground"># {part.title}</span></div>
              ))}
              <div className="pl-4">â”œâ”€â”€ story-ending.md <span className="text-muted-foreground"># Conclusion</span></div>
              <div className="pl-4">â””â”€â”€ story-summary.md <span className="text-muted-foreground"># Rolling summary</span></div>
            </div>
          </div>
        </div>
      )}

      {/* Export Options */}
      <div className="space-y-4 p-4 rounded-lg bg-gray-50 dark:bg-gray-900 border border-gray-200 dark:border-gray-800">
        <h3 className="font-semibold text-sm">Export Options</h3>

        {/* Format Selection */}
        <div className="space-y-2">
          <Label>File Format</Label>
          <div className="p-3 rounded bg-blue-50 dark:bg-blue-950/20 border border-blue-200 dark:border-blue-800">
            <div className="flex items-center gap-2">
              <span className="font-medium text-blue-900 dark:text-blue-100">Markdown (.md)</span>
              <span className="text-xs text-blue-700 dark:text-blue-300">- LLM-optimized with YAML frontmatter</span>
            </div>
            <p className="text-xs text-blue-600 dark:text-blue-400 mt-1">
              Each part includes metadata for better LLM context understanding
            </p>
          </div>
        </div>

        {/* Filename */}
        <div className="space-y-2">
          <Label htmlFor="export-filename">Filename</Label>
          <Input
            id="export-filename"
            value={exportOptions.filename}
            onChange={(e) => setExportOptions({ ...exportOptions, filename: e.target.value })}
            placeholder="story"
          />
          <p className="text-xs text-muted-foreground">
            Extension will be added automatically
          </p>
        </div>

        {/* Include Options */}
        <div className="space-y-3">
          <div className="flex items-center space-x-2">
            <Checkbox
              id="include-metadata"
              checked={exportOptions.includeMetadata}
              onCheckedChange={(checked) =>
                setExportOptions({ ...exportOptions, includeMetadata: checked as boolean })
              }
            />
            <Label htmlFor="include-metadata" className="text-sm font-normal cursor-pointer">
              Include metadata (genre, tone, characters, locations)
            </Label>
          </div>
          <div className="flex items-center space-x-2">
            <Checkbox
              id="include-summary"
              checked={exportOptions.includeSummary}
              onCheckedChange={(checked) =>
                setExportOptions({ ...exportOptions, includeSummary: checked as boolean })
              }
            />
            <Label htmlFor="include-summary" className="text-sm font-normal cursor-pointer">
              Include story summary
            </Label>
          </div>
        </div>
      </div>

      {/* Export Button */}
      <Button
        onClick={handleExport}
        disabled={isExporting || !formData.generatedContent}
        className="w-full gap-2"
        size="lg"
      >
        <Download className="w-4 h-4" />
        {isExporting ? 'Exporting...' : 'Export Story'}
      </Button>

      {/* Export Success Message */}
      {exportSuccess && (
        <div className="p-4 rounded-lg bg-green-50 dark:bg-green-950/20 border border-green-200 dark:border-green-800">
          <div className="flex items-center gap-2 text-green-900 dark:text-green-100">
            <CheckCircle className="w-5 h-5" />
            <div>
              <p className="font-semibold">Export Successful!</p>
              {exportedFilePath && (
                <p className="text-sm mt-1">File saved: {exportedFilePath}</p>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Export Error Message */}
      {exportError && (
        <div className="p-4 rounded-lg bg-red-50 dark:bg-red-950/20 border border-red-200 dark:border-red-800">
          <div className="flex items-center gap-2 text-red-900 dark:text-red-100">
            <AlertCircle className="w-5 h-5" />
            <div>
              <p className="font-semibold">Export Failed</p>
              <p className="text-sm mt-1">{exportError}</p>
            </div>
          </div>
        </div>
      )}

      {/* Info Box */}
      <div className="bg-blue-50 dark:bg-blue-950/20 p-4 rounded-md">
        <p className="text-sm text-blue-900 dark:text-blue-100">
          ðŸ’¡ <strong>Tip:</strong> You can edit the story content before exporting.
          Changes will be saved when you complete the wizard.
        </p>
      </div>
    </WizardFormLayout>
  );
}

