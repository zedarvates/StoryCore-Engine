import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, waitFor, within, cleanup } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { CharacterWizard } from '../CharacterWizard';
import type { Character } from '@/types/character';

// ============================================================================
// Fixed Character Wizard Tests - Corrected Selectors
// ============================================================================

describe('CharacterWizard - Fixed Tests', () => {
  let onComplete: ReturnType<typeof vi.fn>;
  let onCancel: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    onComplete = vi.fn();
    onCancel = vi.fn();
    localStorage.clear();
  });

  afterEach(() => {
    cleanup();
    vi.clearAllMocks();
  });

  describe('Step 1: Basic Identity', () => {
    it('validates all required fields', async () => {
      const user = userEvent.setup();
      render(<CharacterWizard onComplete={onComplete} onCancel={onCancel} />);

      // Click Continue button (not "continue to appearance")
      const continueButton = screen.getByRole('button', { name: /continue/i });
      await user.click(continueButton);

      await waitFor(() => {
        expect(screen.getByText(/character name is required/i)).toBeInTheDocument();
        expect(screen.getByText(/character archetype is required/i)).toBeInTheDocument();
        expect(screen.getByText(/age range is required/i)).toBeInTheDocument();
      });
    });

    it('accepts required fields and proceeds to step 2', async () => {
      const user = userEvent.setup();
      render(<CharacterWizard onComplete={onComplete} onCancel={onCancel} />);

      // Fill required fields
      await user.type(screen.getByLabelText(/name/i), 'Hero');
      
      // Select archetype from combobox
      const archetypeSelect = screen.getByRole('combobox', { name: /archetype/i });
      await user.click(archetypeSelect);
      await user.click(screen.getByRole('option', { name: /protagonist/i }));

      // Select age range
      const ageSelect = screen.getByRole('combobox', { name: /age/i });
      await user.click(ageSelect);
      await user.click(screen.getByRole('option', { name: /young adult/i }));

      // Click Continue
      const continueButton = screen.getByRole('button', { name: /continue/i });
      await user.click(continueButton);

      await waitFor(() => {
        expect(screen.getByText(/appearance/i)).toBeInTheDocument();
      });
    });
  });

  describe('Step 2: Physical Appearance', () => {
    beforeEach(async () => {
      const user = userEvent.setup();
      render(<CharacterWizard onComplete={onComplete} onCancel={onCancel} />);

      // Fill step 1 to reach step 2
      await user.type(screen.getByLabelText(/name/i), 'Hero');
      
      const archetypeSelect = screen.getByRole('combobox', { name: /archetype/i });
      await user.click(archetypeSelect);
      await user.click(screen.getByRole('option', { name: /protagonist/i }));

      const ageSelect = screen.getByRole('combobox', { name: /age/i });
      await user.click(ageSelect);
      await user.click(screen.getByRole('option', { name: /young adult/i }));

      await user.click(screen.getByRole('button', { name: /continue/i }));

      await waitFor(() => {
        expect(screen.getByText(/appearance/i)).toBeInTheDocument();
      });
    });

    it('allows adding distinctive features', async () => {
      const user = userEvent.setup();

      // Find input by placeholder
      const featureInput = screen.getByPlaceholderText(/add a distinctive feature/i);
      await user.type(featureInput, 'Scar on left cheek');
      
      // Find Add button - could be by text or aria-label
      const addButton = screen.getByRole('button', { name: /add/i });
      await user.click(addButton);

      expect(screen.getByText('Scar on left cheek')).toBeInTheDocument();
    });

    it('allows removing distinctive features', async () => {
      const user = userEvent.setup();

      const featureInput = screen.getByPlaceholderText(/add a distinctive feature/i);
      await user.type(featureInput, 'Scar on left cheek');
      await user.click(screen.getByRole('button', { name: /add/i }));

      expect(screen.getByText('Scar on left cheek')).toBeInTheDocument();

      // Remove button - use more flexible selector
      const removeButton = screen.getByRole('button', { name: /remove|delete|trash/i });
      await user.click(removeButton);

      expect(screen.queryByText('Scar on left cheek')).not.toBeInTheDocument();
    });

    it('displays LLM generation button', () => {
      expect(screen.getByRole('button', { name: /generate|ai/i })).toBeInTheDocument();
    });
  });

  describe('Step 3: Personality', () => {
    beforeEach(async () => {
      const user = userEvent.setup();
      render(<CharacterWizard onComplete={onComplete} onCancel={onCancel} />);

      // Navigate to step 3
      await user.type(screen.getByLabelText(/name/i), 'Hero');
      
      const archetypeSelect = screen.getByRole('combobox', { name: /archetype/i });
      await user.click(archetypeSelect);
      await user.click(screen.getByRole('option', { name: /protagonist/i }));

      const ageSelect = screen.getByRole('combobox', { name: /age/i });
      await user.click(ageSelect);
      await user.click(screen.getByRole('option', { name: /young adult/i }));

      await user.click(screen.getByRole('button', { name: /continue/i }));
      await waitFor(() => expect(screen.getByText(/appearance/i)).toBeInTheDocument());

      await user.click(screen.getByRole('button', { name: /continue/i }));
      await waitFor(() => expect(screen.getByText(/personality/i)).toBeInTheDocument());
    });

    it('allows adding personality traits', async () => {
      const user = userEvent.setup();

      const traitInput = screen.getByPlaceholderText(/add a trait/i);
      await user.type(traitInput, 'Brave');
      
      const addButton = screen.getByRole('button', { name: /add/i });
      await user.click(addButton);

      expect(screen.getByText('Brave')).toBeInTheDocument();
    });

    it('validates maximum traits limit', async () => {
      const user = userEvent.setup();

      const traitInput = screen.getByPlaceholderText(/add a trait/i);
      const addButton = screen.getByRole('button', { name: /add/i });

      // Add 11 traits (exceeds limit of 10)
      for (let i = 1; i <= 11; i++) {
        await user.clear(traitInput);
        await user.type(traitInput, `Trait ${i}`);
        await user.click(addButton);
      }

      // Try to proceed
      await user.click(screen.getByRole('button', { name: /continue/i }));

      await waitFor(() => {
        expect(screen.getByText(/maximum 10/i)).toBeInTheDocument();
      });
    });
  });

  describe('Step 4: Background', () => {
    beforeEach(async () => {
      const user = userEvent.setup();
      render(<CharacterWizard onComplete={onComplete} onCancel={onCancel} />);

      // Navigate to step 4
      await user.type(screen.getByLabelText(/name/i), 'Hero');
      
      const archetypeSelect = screen.getByRole('combobox', { name: /archetype/i });
      await user.click(archetypeSelect);
      await user.click(screen.getByRole('option', { name: /protagonist/i }));

      const ageSelect = screen.getByRole('combobox', { name: /age/i });
      await user.click(ageSelect);
      await user.click(screen.getByRole('option', { name: /young adult/i }));

      await user.click(screen.getByRole('button', { name: /continue/i }));
      await waitFor(() => expect(screen.getByText(/appearance/i)).toBeInTheDocument());

      await user.click(screen.getByRole('button', { name: /continue/i }));
      await waitFor(() => expect(screen.getByText(/personality/i)).toBeInTheDocument());

      await user.click(screen.getByRole('button', { name: /continue/i }));
      await waitFor(() => expect(screen.getByText(/background/i)).toBeInTheDocument());
    });

    it('allows filling background fields', async () => {
      const user = userEvent.setup();

      await user.type(
        screen.getByLabelText(/origin|upbringing/i),
        'Born in a small village'
      );
      await user.type(
        screen.getByLabelText(/occupation|skills/i),
        'Skilled warrior'
      );

      expect(screen.getByDisplayValue('Born in a small village')).toBeInTheDocument();
      expect(screen.getByDisplayValue('Skilled warrior')).toBeInTheDocument();
    });

    it('allows adding significant events', async () => {
      const user = userEvent.setup();

      const eventInput = screen.getByPlaceholderText(/significant event/i);
      await user.type(eventInput, 'Lost parents in war');
      await user.click(screen.getByRole('button', { name: /add/i }));

      expect(screen.getByText('Lost parents in war')).toBeInTheDocument();
    });
  });

  describe('Step 5: Relationships', () => {
    beforeEach(async () => {
      const user = userEvent.setup();
      render(<CharacterWizard onComplete={onComplete} onCancel={onCancel} />);

      // Navigate to step 5
      await user.type(screen.getByLabelText(/name/i), 'Hero');
      
      const archetypeSelect = screen.getByRole('combobox', { name: /archetype/i });
      await user.click(archetypeSelect);
      await user.click(screen.getByRole('option', { name: /protagonist/i }));

      const ageSelect = screen.getByRole('combobox', { name: /age/i });
      await user.click(ageSelect);
      await user.click(screen.getByRole('option', { name: /young adult/i }));

      // Navigate through steps
      await user.click(screen.getByRole('button', { name: /continue/i }));
      await waitFor(() => expect(screen.getByText(/appearance/i)).toBeInTheDocument());

      await user.click(screen.getByRole('button', { name: /continue/i }));
      await waitFor(() => expect(screen.getByText(/personality/i)).toBeInTheDocument());

      await user.click(screen.getByRole('button', { name: /continue/i }));
      await waitFor(() => expect(screen.getByText(/background/i)).toBeInTheDocument());

      await user.click(screen.getByRole('button', { name: /continue/i }));
      await waitFor(() => expect(screen.getByText(/relationships/i)).toBeInTheDocument());
    });

    it('allows adding a relationship', async () => {
      const user = userEvent.setup();

      await user.type(screen.getByLabelText(/character name/i), 'Mentor');
      
      const typeSelect = screen.getByRole('combobox', { name: /type/i });
      await user.click(typeSelect);
      await user.click(screen.getByRole('option', { name: /mentor/i }));

      await user.click(screen.getByRole('button', { name: /add relationship/i }));

      expect(screen.getByText('Mentor')).toBeInTheDocument();
    });

    it('allows deleting a relationship', async () => {
      const user = userEvent.setup();

      // Add a relationship
      await user.type(screen.getByLabelText(/character name/i), 'Mentor');
      
      const typeSelect = screen.getByRole('combobox', { name: /type/i });
      await user.click(typeSelect);
      await user.click(screen.getByRole('option', { name: /mentor/i }));

      await user.click(screen.getByRole('button', { name: /add relationship/i }));

      expect(screen.getByText('Mentor')).toBeInTheDocument();

      // Delete it - use flexible selector
      const deleteButton = screen.getByRole('button', { name: /delete|remove|trash/i });
      await user.click(deleteButton);

      expect(screen.queryByText('Mentor')).not.toBeInTheDocument();
    });
  });

  describe('Step 6: Review and Finalize', () => {
    it('displays all entered information', async () => {
      const user = userEvent.setup();
      render(<CharacterWizard onComplete={onComplete} onCancel={onCancel} />);

      // Fill all steps
      await user.type(screen.getByLabelText(/name/i), 'Test Hero');
      
      const archetypeSelect = screen.getByRole('combobox', { name: /archetype/i });
      await user.click(archetypeSelect);
      await user.click(screen.getByRole('option', { name: /protagonist/i }));

      const ageSelect = screen.getByRole('combobox', { name: /age/i });
      await user.click(ageSelect);
      await user.click(screen.getByRole('option', { name: /young adult/i }));

      // Navigate to review
      for (let i = 0; i < 5; i++) {
        await user.click(screen.getByRole('button', { name: /continue/i }));
        await waitFor(() => {}, { timeout: 1000 });
      }

      await waitFor(() => {
        expect(screen.getByText(/review|finalize/i)).toBeInTheDocument();
        expect(screen.getByText('Test Hero')).toBeInTheDocument();
      });
    });

    it('calls onComplete with character data when submitted', async () => {
      const user = userEvent.setup();
      render(<CharacterWizard onComplete={onComplete} onCancel={onCancel} />);

      // Fill minimum required fields
      await user.type(screen.getByLabelText(/name/i), 'Test Hero');
      
      const archetypeSelect = screen.getByRole('combobox', { name: /archetype/i });
      await user.click(archetypeSelect);
      await user.click(screen.getByRole('option', { name: /protagonist/i }));

      const ageSelect = screen.getByRole('combobox', { name: /age/i });
      await user.click(ageSelect);
      await user.click(screen.getByRole('option', { name: /young adult/i }));

      // Navigate to review and submit
      for (let i = 0; i < 5; i++) {
        await user.click(screen.getByRole('button', { name: /continue/i }));
        await waitFor(() => {}, { timeout: 1000 });
      }

      await waitFor(() => {
        expect(screen.getByText(/review|finalize/i)).toBeInTheDocument();
      });

      // Click Complete button (last step uses "Complete" not "create character")
      await user.click(screen.getByRole('button', { name: /complete|save/i }));

      await waitFor(() => {
        expect(onComplete).toHaveBeenCalledTimes(1);
        const character = onComplete.mock.calls[0][0] as Character;
        expect(character.name).toBe('Test Hero');
        expect(character.character_id).toBeDefined();
      });
    });
  });

  describe('Auto-save functionality', () => {
    it('saves wizard state to localStorage', async () => {
      const user = userEvent.setup();
      render(<CharacterWizard onComplete={onComplete} onCancel={onCancel} />);

      await user.type(screen.getByLabelText(/name/i), 'Auto Save Test');

      // Wait for auto-save
      await waitFor(
        () => {
          const saved = localStorage.getItem('wizard-character');
          expect(saved).toBeTruthy();
        },
        { timeout: 3000 }
      );
    });
  });

  describe('Event emission', () => {
    it('emits character-created event on completion', async () => {
      const user = userEvent.setup();
      const eventListener = vi.fn();
      window.addEventListener('character-created', eventListener);

      render(<CharacterWizard onComplete={onComplete} onCancel={onCancel} />);

      // Fill and submit
      await user.type(screen.getByLabelText(/name/i), 'Event Test');
      
      const archetypeSelect = screen.getByRole('combobox', { name: /archetype/i });
      await user.click(archetypeSelect);
      await user.click(screen.getByRole('option', { name: /protagonist/i }));

      const ageSelect = screen.getByRole('combobox', { name: /age/i });
      await user.click(ageSelect);
      await user.click(screen.getByRole('option', { name: /young adult/i }));

      for (let i = 0; i < 5; i++) {
        await user.click(screen.getByRole('button', { name: /continue/i }));
        await waitFor(() => {}, { timeout: 1000 });
      }

      await waitFor(() => {
        expect(screen.getByText(/review|finalize/i)).toBeInTheDocument();
      });

      await user.click(screen.getByRole('button', { name: /complete|save/i }));

      await waitFor(() => {
        expect(eventListener).toHaveBeenCalled();
      });

      window.removeEventListener('character-created', eventListener);
    });
  });
});
