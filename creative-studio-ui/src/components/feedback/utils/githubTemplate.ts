/**
 * GitHub Template Generator Utility
 * 
 * Generates Markdown-formatted GitHub issue templates and URLs
 * for Manual Mode feedback submission.
 */

import { ReportPayload } from '../types';

/**
 * Format report payload as Markdown template
 * 
 * Requirements: 6.1
 * 
 * @param payload Report payload
 * @returns Markdown-formatted issue body
 */
export function formatIssueBody(payload: ReportPayload): string {
  const reportTypeLabel = {
    bug: 'Bug Report',
    enhancement: 'Feature Request',
    question: 'Question',
  }[payload.report_type];

  let template = `## Report Type
${reportTypeLabel}

## System Context
- **StoryCore Version:** ${payload.system_info.storycore_version}
- **Active Module:** ${payload.module_context.active_module}
- **OS Platform:** ${payload.system_info.os_platform} ${payload.system_info.os_version}
- **Python Version:** ${payload.system_info.python_version}
- **Language:** ${payload.system_info.language}

## Description
${payload.user_input.description}
`;

  // Add reproduction steps if provided
  if (payload.user_input.reproduction_steps && payload.user_input.reproduction_steps.trim()) {
    template += `
## Reproduction Steps
${payload.user_input.reproduction_steps}
`;
  }

  // Add diagnostics section with collapsible details
  template += `
## Diagnostics
`;

  // Add stacktrace if available
  if (payload.diagnostics.stacktrace) {
    template += `
<details>
<summary>Stacktrace</summary>

\`\`\`
${payload.diagnostics.stacktrace}
\`\`\`
</details>
`;
  }

  // Add logs if available (Phase 2)
  if (payload.diagnostics.logs && payload.diagnostics.logs.length > 0) {
    template += `
<details>
<summary>Application Logs (Last ${payload.diagnostics.logs.length} lines)</summary>

\`\`\`
${payload.diagnostics.logs.join('\n')}
\`\`\`
</details>
`;
  }

  // Add memory state if available (Phase 2)
  if (payload.diagnostics.memory_usage_mb > 0) {
    template += `
<details>
<summary>Memory State</summary>

\`\`\`json
${JSON.stringify({
  memory_usage_mb: payload.diagnostics.memory_usage_mb,
  process_state: payload.diagnostics.process_state,
}, null, 2)}
\`\`\`
</details>
`;
  }

  // Add footer
  template += `

---
*This issue was automatically generated by StoryCore-Engine Feedback & Diagnostics module*
*Timestamp: ${payload.timestamp}*
`;

  return template;
}

/**
 * Generate GitHub issue creation URL with pre-filled template
 * 
 * Requirements: 1.1, 1.4
 * 
 * @param payload Report payload
 * @returns GitHub issue creation URL
 */
export function generateGitHubUrl(payload: ReportPayload): string {
  const repository = 'zedarvates/StoryCore-Engine';
  const baseUrl = `https://github.com/${repository}/issues/new`;

  // Generate issue title
  const titlePrefix = {
    bug: '[Bug]',
    enhancement: '[Feature Request]',
    question: '[Question]',
  }[payload.report_type];

  const title = `${titlePrefix} ${payload.user_input.description.substring(0, 50)}${
    payload.user_input.description.length > 50 ? '...' : ''
  }`;

  // Generate issue body
  const body = formatIssueBody(payload);

  // Generate labels
  const labels = generateIssueLabels(payload);

  // Encode URL parameters
  const params = new URLSearchParams({
    title,
    body,
    labels: labels.join(','),
  });

  return `${baseUrl}?${params.toString()}`;
}

/**
 * Generate issue labels based on payload context
 * 
 * Requirements: 6.2, 6.3, 6.4, 6.5, 6.6
 * 
 * @param payload Report payload
 * @returns Array of label strings
 */
export function generateIssueLabels(payload: ReportPayload): string[] {
  const labels: string[] = ['from-storycore'];

  // Add report type label
  if (payload.report_type === 'bug') {
    labels.push('bug');
  } else if (payload.report_type === 'enhancement') {
    labels.push('enhancement');
  } else if (payload.report_type === 'question') {
    labels.push('question');
  }

  // Add module label if available
  if (payload.module_context.active_module && payload.module_context.active_module !== 'unknown') {
    labels.push(`module:${payload.module_context.active_module}`);
  }

  // Add OS label
  const osPlatform = payload.system_info.os_platform.toLowerCase();
  if (osPlatform.includes('windows') || osPlatform.includes('win32')) {
    labels.push('os:windows');
  } else if (osPlatform.includes('darwin') || osPlatform.includes('mac')) {
    labels.push('os:macos');
  } else if (osPlatform.includes('linux')) {
    labels.push('os:linux');
  }

  return labels;
}
