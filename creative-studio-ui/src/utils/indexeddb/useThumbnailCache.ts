/**
 * React hook for ThumbnailCache - provides async loading and preloading of thumbnails
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import { ThumbnailCache, ThumbnailData } from './ThumbnailCache';

interface ThumbnailState {
  data: ThumbnailData | null;
  loading: boolean;
  error: string | null;
}

interface UseThumbnailCacheOptions {
  preloadAdjacent?: boolean;
  adjacentCount?: number;
}

const globalCache = new ThumbnailCache();

export function useThumbnailCache(videoUrl: string, timestamp: number, options: UseThumbnailCacheOptions = {}) {
  const { preloadAdjacent = true, adjacentCount = 5 } = options;
  const [state, setState] = useState<ThumbnailState>({
    data: null,
    loading: true,
    error: null
  });

  const cacheRef = useRef(globalCache);
  const preloadTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const loadThumbnail = useCallback(async () => {
    if (!videoUrl) return;

    setState(prev => ({ ...prev, loading: true, error: null }));

    try {
      await cacheRef.current.initialize();

      const cached = await cacheRef.current.get(videoUrl, timestamp);

      if (cached) {
        setState({
          data: cached,
          loading: false,
          error: null
        });

        // Preload adjacent thumbnails
        if (preloadAdjacent) {
          preloadAdjacentThumbnails(videoUrl, timestamp, adjacentCount);
        }
      } else {
        // Thumbnail not cached, will be generated by worker
        setState({
          data: null,
          loading: false,
          error: 'Thumbnail not available'
        });
      }
    } catch (error) {
      setState({
        data: null,
        loading: false,
        error: error instanceof Error ? error.message : 'Failed to load thumbnail'
      });
    }
  }, [videoUrl, timestamp, preloadAdjacent, adjacentCount]);

  const preloadAdjacentThumbnails = useCallback(async (url: string, time: number, count: number) => {
    if (preloadTimeoutRef.current) {
      clearTimeout(preloadTimeoutRef.current);
    }

    preloadTimeoutRef.current = setTimeout(async () => {
      try {
        const frameRate = 30; // Assume 30fps, could be made configurable
        const frameDuration = 1 / frameRate;

        // Preload thumbnails before and after current position
        const promises = [];

        for (let i = 1; i <= count; i++) {
          // Before
          const beforeTime = Math.max(0, time - i * frameDuration);
          promises.push(cacheRef.current.get(url, beforeTime));

          // After
          const afterTime = time + i * frameDuration;
          promises.push(cacheRef.current.get(url, afterTime));
        }

        await Promise.allSettled(promises);
      } catch (error) {
        console.warn('Failed to preload adjacent thumbnails:', error);
      }
    }, 100); // Small delay to avoid blocking
  }, []);

  const generateThumbnail = useCallback(async (blob: Blob, width: number, height: number) => {
    if (!videoUrl) return;

    try {
      await cacheRef.current.initialize();
      await cacheRef.current.set(videoUrl, timestamp, blob, width, height);

      setState({
        data: await cacheRef.current.get(videoUrl, timestamp),
        loading: false,
        error: null
      });
    } catch (error) {
      setState(prev => ({
        ...prev,
        loading: false,
        error: error instanceof Error ? error.message : 'Failed to generate thumbnail'
      }));
    }
  }, [videoUrl, timestamp]);

  useEffect(() => {
    loadThumbnail();
  }, [loadThumbnail]);

  useEffect(() => {
    return () => {
      if (preloadTimeoutRef.current) {
        clearTimeout(preloadTimeoutRef.current);
      }
    };
  }, []);

  return {
    ...state,
    generateThumbnail,
    reload: loadThumbnail
  };
}

export function useThumbnailCacheStats() {
  const [stats, setStats] = useState<{
    memoryItems: number;
    diskItems: number;
    memorySizeMB: number;
    diskSizeMB: number;
  } | null>(null);

  const loadStats = useCallback(async () => {
    try {
      await globalCache.initialize();
      const currentStats = await globalCache.getStats();
      setStats(currentStats);
    } catch (error) {
      console.warn('Failed to load cache stats:', error);
    }
  }, []);

  const clearCache = useCallback(async () => {
    try {
      await globalCache.clear();
      await loadStats();
    } catch (error) {
      console.warn('Failed to clear cache:', error);
    }
  }, [loadStats]);

  useEffect(() => {
    loadStats();
  }, [loadStats]);

  return {
    stats,
    clearCache,
    reloadStats: loadStats
  };
}