// ============================================================================
// Story File I/O Utilities
// ============================================================================
// This module provides functions for reading and writing story.md files
// to/from the file system. It handles markdown format conversion and
// gracefully handles missing files.
// ============================================================================

import type { Story } from '@/types/story';

// ============================================================================
// Constants
// ============================================================================

const STORY_FILE_NAME = 'story.md';
const STORY_DIR_NAME = 'story';

// ============================================================================
// Markdown Conversion Functions
// ============================================================================

/**
 * Converts a Story object to markdown format
 */
export function storyToMarkdown(story: Story): string {
  const lines: string[] = [];

  // Title
  lines.push(`# ${story.title || 'Untitled Story'}`);
  lines.push('');

  // Story Information
  lines.push('## Story Information');
  lines.push('');
  lines.push(`**Genre**: ${story.genre.join(', ') || '[Not specified]'}`);
  lines.push(`**Tone**: ${story.tone.join(', ') || '[Not specified]'}`);
  lines.push(`**Length**: ${story.length || 'medium'}`);
  lines.push('');

  // Summary
  lines.push('## Summary');
  lines.push('');
  lines.push(story.summary || '[Write a brief summary of your story here - 2-3 sentences describing the main plot and characters]');
  lines.push('');

  // Main Content
  lines.push('## Main Content');
  lines.push('');
  lines.push(story.content || '[Your story content begins here. The storyteller wizard will help you generate and refine this content.]');
  lines.push('');

  // Characters Used
  if (story.charactersUsed && story.charactersUsed.length > 0) {
    lines.push('## Characters');
    lines.push('');
    story.charactersUsed.forEach((char) => {
      lines.push(`- **${char.name}**: ${char.role}`);
    });
    lines.push('');
  }

  // Locations Used
  if (story.locationsUsed && story.locationsUsed.length > 0) {
    lines.push('## Locations');
    lines.push('');
    story.locationsUsed.forEach((loc) => {
      lines.push(`- **${loc.name}**: ${loc.significance}`);
    });
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push('*This file is automatically read and updated by the StoryCore-Engine Storyteller Wizard.*');
  lines.push('*You can also edit it manually using any text editor.*');

  return lines.join('\n');
}

/**
 * Parses markdown content into a Story object
 */
export function markdownToStory(markdown: string, existingStory?: Partial<Story>): Story {
  const lines = markdown.split('\n');

  // Initialize story with defaults or existing values
  const story: Story = {
    id: existingStory?.id || crypto.randomUUID(),
    title: '',
    content: '',
    summary: '',
    genre: existingStory?.genre || [],
    tone: existingStory?.tone || [],
    length: existingStory?.length || 'medium',
    charactersUsed: existingStory?.charactersUsed || [],
    locationsUsed: existingStory?.locationsUsed || [],
    autoGeneratedElements: existingStory?.autoGeneratedElements || [],
    createdAt: existingStory?.createdAt || new Date(),
    updatedAt: new Date(),
    version: (existingStory?.version || 0) + 1,
    worldId: existingStory?.worldId,
  };

  let currentSection = '';
  let contentBuffer: string[] = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Parse title (# Title)
    if (line.startsWith('# ') && !story.title) {
      story.title = line.substring(2).trim();
      continue;
    }

    // Parse section headers (## Section)
    if (line.startsWith('## ')) {
      // Save previous section content
      if (currentSection === 'Main Content' || currentSection === 'Content') {
        story.content = contentBuffer.join('\n').trim();
        contentBuffer = [];
      } else if (currentSection === 'Summary') {
        story.summary = contentBuffer.join('\n').trim();
        contentBuffer = [];
      }

      currentSection = line.substring(3).trim();
      continue;
    }

    // Parse metadata fields
    if (line.startsWith('**Genre**:')) {
      const genreText = line.substring(10).trim();
      story.genre = genreText
        .split(',')
        .map((g) => g.trim())
        .filter((g) => g && g !== '[Not specified]');
      continue;
    }

    if (line.startsWith('**Tone**:')) {
      const toneText = line.substring(9).trim();
      story.tone = toneText
        .split(',')
        .map((t) => t.trim())
        .filter((t) => t && t !== '[Not specified]');
      continue;
    }

    if (line.startsWith('**Length**:')) {
      const lengthText = line.substring(11).trim().toLowerCase();
      if (lengthText === 'short' || lengthText === 'medium' || lengthText === 'long') {
        story.length = lengthText;
      }
      continue;
    }

    // Collect content for current section
    if (currentSection === 'Main Content' || currentSection === 'Content' || currentSection === 'Summary') {
      contentBuffer.push(line);
    }
  }

  // Save any remaining content
  if (currentSection === 'Main Content' || currentSection === 'Content') {
    story.content = contentBuffer.join('\n').trim();
  } else if (currentSection === 'Summary') {
    story.summary = contentBuffer.join('\n').trim();
  }

  return story;
}

// ============================================================================
// File I/O Functions
// ============================================================================

/**
 * Loads story content from a story.md file
 * 
 * @param projectPath - Path to the project directory (or File object for the story.md file)
 * @returns Story object or null if file doesn't exist
 * @throws Error if file read operation fails
 */
export async function loadStoryFromFile(projectPath: string | File): Promise<Story | null> {
  try {
    let file: File;

    if (projectPath instanceof File) {
      // Direct file object provided
      file = projectPath;
    } else {
      // For browser environment, we need to use File System Access API
      // This requires user interaction, so we'll throw an error with instructions
      throw new Error(
        'Browser file system access requires user interaction. ' +
        'Please use the file picker to select the story.md file.'
      );
    }

    // Read file content
    const content = await file.text();

    // Parse markdown to Story object
    const story = markdownToStory(content);

    return story;
  } catch (error) {
    // If file doesn't exist or can't be read, return null
    if (error instanceof Error && error.message.includes('not found')) {
      return null;
    }

    // Re-throw other errors
    throw error;
  }
}

/**
 * Saves story content to the file system.
 * In Electron, it creates a 'story/' directory with individual part files.
 * In Browser, it downloads the combined markdown.
 */
export async function saveStoryToDisk(projectPath: string, story: Story): Promise<void> {
  // If we have Electron API, use the directory-based storage
  if (window.electronAPI?.fs) {
    try {
      const storyDir = `${projectPath}/${STORY_DIR_NAME}`;

      // Ensure directory exists
      await window.electronAPI.fs.mkdir(storyDir);

      // Save combined markdown for compatibility
      const markdown = storyToMarkdown(story);
      await window.electronAPI.fs.writeFile(`${projectPath}/${STORY_FILE_NAME}`, markdown);

      // Save individual parts
      if (story.parts && story.parts.length > 0) {
        for (const part of story.parts) {
          let fileName = '';
          if (part.type === 'intro') fileName = 'story-intro.txt';
          else if (part.type === 'ending') fileName = 'story-end.txt';
          else fileName = `story-Chapitre${part.order - 1}.txt`;

          await window.electronAPI.fs.writeFile(`${storyDir}/${fileName}`, part.content);
        }

        // Save the rolling summary
        const lastPart = story.parts[story.parts.length - 1];
        await window.electronAPI.fs.writeFile(`${storyDir}/story-resume.txt`, lastPart.summary);
      }

      return;
    } catch (error) {
      console.error('[StoryFileIO] Electron save failed:', error);
      // Fallback to basic save or re-throw
    }
  }

  // Fallback / Browser behavior
  await saveStoryToFile(projectPath, story);
}

/**
 * Saves story content using browser APIs (download or file picker)
 */
export async function saveStoryToFile(projectPath: string, story: Story): Promise<void> {
  try {
    // Convert story to markdown
    const markdown = storyToMarkdown(story);

    // In browser environment, we need to use File System Access API
    // or download the file
    if ('showSaveFilePicker' in window) {
      // Use File System Access API if available
      const options = {
        suggestedName: STORY_FILE_NAME,
        types: [
          {
            description: 'Markdown Files',
            accept: {
              'text/markdown': ['.md'],
            },
          },
        ],
      };

      const handle = await (window as any).showSaveFilePicker(options);
      const writable = await handle.createWritable();
      await writable.write(markdown);
      await writable.close();
    } else {
      // Fallback: Download the file
      const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = STORY_FILE_NAME;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Failed to save story file: ${error.message}`);
    }
    throw new Error('Failed to save story file: Unknown error');
  }
}

/**
 * Creates a new story.md file with default template content
 * 
 * @param projectName - Name of the project
 * @returns Story object with default template content
 */
export function createDefaultStory(projectName: string): Story {
  return {
    id: crypto.randomUUID(),
    title: projectName,
    content: '[Your story content begins here. The storyteller wizard will help you generate and refine this content.]',
    summary: '[Write a brief summary of your story here - 2-3 sentences describing the main plot and characters]',
    genre: [],
    tone: [],
    length: 'medium',
    charactersUsed: [],
    locationsUsed: [],
    autoGeneratedElements: [],
    createdAt: new Date(),
    updatedAt: new Date(),
    version: 1,
  };
}

/**
 * Loads story from file with fallback to default story
 * 
 * @param projectPath - Path to the project directory or File object
 * @param projectName - Name of the project (used for default story)
 * @returns Story object (either loaded from file or default)
 */
export async function loadStoryOrDefault(
  projectPath: string | File,
  projectName: string
): Promise<Story> {
  try {
    const story = await loadStoryFromFile(projectPath);
    if (story) {
      return story;
    }
  } catch (error) {
    console.warn('Failed to load story file, using default:', error);
  }

  // Return default story if file doesn't exist or can't be loaded
  return createDefaultStory(projectName);
}

// ============================================================================
// File Picker Helpers
// ============================================================================

/**
 * Opens a file picker to select a story.md file
 * 
 * @returns Selected File object or null if cancelled
 */
export async function pickStoryFile(): Promise<File | null> {
  return new Promise((resolve) => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.md,text/markdown';

    input.onchange = (event) => {
      const target = event.target as HTMLInputElement;
      const file = target.files?.[0];
      resolve(file || null);
    };

    input.oncancel = () => {
      resolve(null);
    };

    input.click();
  });
}

/**
 * Loads story using file picker
 * 
 * @returns Story object or null if cancelled or failed
 */
export async function loadStoryWithPicker(): Promise<Story | null> {
  try {
    const file = await pickStoryFile();
    if (!file) {
      return null;
    }

    return await loadStoryFromFile(file);
  } catch (error) {
    console.error('Failed to load story with picker:', error);
    return null;
  }
}
