// ============================================================================
// Story File I/O Tests
// ============================================================================

import { describe, it, expect, beforeEach } from 'vitest';
import {
  storyToMarkdown,
  markdownToStory,
  createDefaultStory,
} from '../storyFileIO';
import type { Story } from '@/types/story';

describe('storyFileIO', () => {
  let sampleStory: Story;

  beforeEach(() => {
    sampleStory = {
      id: 'test-story-123',
      title: 'The Adventure Begins',
      content: 'Once upon a time, in a land far away...\n\nThe hero embarked on a journey.',
      summary: 'A hero embarks on an epic journey to save the kingdom.',
      genre: ['Fantasy', 'Adventure'],
      tone: ['Epic', 'Heroic'],
      length: 'medium',
      charactersUsed: [
        { id: 'char-1', name: 'Hero', role: 'Protagonist' },
        { id: 'char-2', name: 'Villain', role: 'Antagonist' },
      ],
      locationsUsed: [
        { id: 'loc-1', name: 'Kingdom', significance: 'Starting point' },
        { id: 'loc-2', name: 'Dark Forest', significance: 'First challenge' },
      ],
      autoGeneratedElements: [],
      createdAt: new Date('2024-01-01'),
      updatedAt: new Date('2024-01-02'),
      version: 1,
    };
  });

  describe('storyToMarkdown', () => {
    it('should convert a complete story to markdown format', () => {
      const markdown = storyToMarkdown(sampleStory);

      expect(markdown).toContain('# The Adventure Begins');
      expect(markdown).toContain('**Genre**: Fantasy, Adventure');
      expect(markdown).toContain('**Tone**: Epic, Heroic');
      expect(markdown).toContain('**Length**: medium');
      expect(markdown).toContain('## Summary');
      expect(markdown).toContain('A hero embarks on an epic journey');
      expect(markdown).toContain('## Main Content');
      expect(markdown).toContain('Once upon a time');
      expect(markdown).toContain('## Characters');
      expect(markdown).toContain('- **Hero**: Protagonist');
      expect(markdown).toContain('- **Villain**: Antagonist');
      expect(markdown).toContain('## Locations');
      expect(markdown).toContain('- **Kingdom**: Starting point');
      expect(markdown).toContain('- **Dark Forest**: First challenge');
    });

    it('should handle story with empty title', () => {
      const storyWithoutTitle = { ...sampleStory, title: '' };
      const markdown = storyToMarkdown(storyWithoutTitle);

      expect(markdown).toContain('# Untitled Story');
    });

    it('should handle story with empty genre and tone', () => {
      const storyWithoutMetadata = {
        ...sampleStory,
        genre: [],
        tone: [],
      };
      const markdown = storyToMarkdown(storyWithoutMetadata);

      expect(markdown).toContain('**Genre**: [Not specified]');
      expect(markdown).toContain('**Tone**: [Not specified]');
    });

    it('should handle story without characters', () => {
      const storyWithoutCharacters = {
        ...sampleStory,
        charactersUsed: [],
      };
      const markdown = storyToMarkdown(storyWithoutCharacters);

      expect(markdown).not.toContain('## Characters');
    });

    it('should handle story without locations', () => {
      const storyWithoutLocations = {
        ...sampleStory,
        locationsUsed: [],
      };
      const markdown = storyToMarkdown(storyWithoutLocations);

      expect(markdown).not.toContain('## Locations');
    });

    it('should include footer with instructions', () => {
      const markdown = storyToMarkdown(sampleStory);

      expect(markdown).toContain('*This file is automatically read and updated by the StoryCore-Engine Storyteller Wizard.*');
      expect(markdown).toContain('*You can also edit it manually using any text editor.*');
    });
  });

  describe('markdownToStory', () => {
    it('should parse a complete markdown file to Story object', () => {
      const markdown = `# The Adventure Begins

## Story Information

**Genre**: Fantasy, Adventure
**Tone**: Epic, Heroic
**Length**: medium

## Summary

A hero embarks on an epic journey to save the kingdom.

## Main Content

Once upon a time, in a land far away...

The hero embarked on a journey.

## Characters

- **Hero**: Protagonist
- **Villain**: Antagonist

## Locations

- **Kingdom**: Starting point
- **Dark Forest**: First challenge

---

*This file is automatically read and updated by the StoryCore-Engine Storyteller Wizard.*
*You can also edit it manually using any text editor.*`;

      const story = markdownToStory(markdown);

      expect(story.title).toBe('The Adventure Begins');
      expect(story.genre).toEqual(['Fantasy', 'Adventure']);
      expect(story.tone).toEqual(['Epic', 'Heroic']);
      expect(story.length).toBe('medium');
      expect(story.summary).toContain('A hero embarks on an epic journey');
      expect(story.content).toContain('Once upon a time');
      expect(story.content).toContain('The hero embarked on a journey');
    });

    it('should handle markdown with minimal content', () => {
      const markdown = `# Simple Story

## Summary

A simple summary.

## Main Content

Simple content.`;

      const story = markdownToStory(markdown);

      expect(story.title).toBe('Simple Story');
      expect(story.summary).toBe('A simple summary.');
      expect(story.content).toBe('Simple content.');
      expect(story.genre).toEqual([]);
      expect(story.tone).toEqual([]);
    });

    it('should handle markdown with "Content" instead of "Main Content"', () => {
      const markdown = `# Story Title

## Content

This is the story content.`;

      const story = markdownToStory(markdown);

      expect(story.content).toBe('This is the story content.');
    });

    it('should preserve existing story metadata when provided', () => {
      const existingStory: Partial<Story> = {
        id: 'existing-id',
        genre: ['Sci-Fi'],
        tone: ['Dark'],
        createdAt: new Date('2023-01-01'),
        version: 5,
      };

      const markdown = `# New Title

## Summary

New summary.

## Main Content

New content.`;

      const story = markdownToStory(markdown, existingStory);

      expect(story.id).toBe('existing-id');
      expect(story.createdAt).toEqual(new Date('2023-01-01'));
      expect(story.version).toBe(6); // Incremented
      expect(story.title).toBe('New Title'); // Updated from markdown
    });

    it('should generate new ID if not provided', () => {
      const markdown = `# Test Story

## Main Content

Test content.`;

      const story = markdownToStory(markdown);

      expect(story.id).toBeTruthy();
      expect(story.id.length).toBeGreaterThan(0);
    });

    it('should handle empty genre and tone fields', () => {
      const markdown = `# Story

**Genre**: [Not specified]
**Tone**: [Not specified]

## Main Content

Content here.`;

      const story = markdownToStory(markdown);

      expect(story.genre).toEqual([]);
      expect(story.tone).toEqual([]);
    });

    it('should handle multiline content correctly', () => {
      const markdown = `# Story

## Main Content

Line 1

Line 2

Line 3`;

      const story = markdownToStory(markdown);

      expect(story.content).toContain('Line 1');
      expect(story.content).toContain('Line 2');
      expect(story.content).toContain('Line 3');
    });

    it('should update the updatedAt timestamp', () => {
      const beforeParse = new Date();
      const markdown = `# Test

## Main Content

Test`;

      const story = markdownToStory(markdown);

      expect(story.updatedAt.getTime()).toBeGreaterThanOrEqual(beforeParse.getTime());
    });
  });

  describe('round-trip conversion', () => {
    it('should preserve story data through markdown conversion and back', () => {
      // Convert to markdown
      const markdown = storyToMarkdown(sampleStory);

      // Convert back to story
      const parsedStory = markdownToStory(markdown, {
        id: sampleStory.id,
        createdAt: sampleStory.createdAt,
        version: sampleStory.version - 1, // Will be incremented
      });

      // Verify key fields are preserved
      expect(parsedStory.title).toBe(sampleStory.title);
      expect(parsedStory.genre).toEqual(sampleStory.genre);
      expect(parsedStory.tone).toEqual(sampleStory.tone);
      expect(parsedStory.length).toBe(sampleStory.length);
      expect(parsedStory.summary).toBe(sampleStory.summary);
      expect(parsedStory.content).toBe(sampleStory.content);
      expect(parsedStory.id).toBe(sampleStory.id);
    });

    it('should handle special characters in content', () => {
      const storyWithSpecialChars = {
        ...sampleStory,
        content: 'Content with **bold**, *italic*, and `code`.',
        summary: 'Summary with [links](http://example.com) and #hashtags.',
      };

      const markdown = storyToMarkdown(storyWithSpecialChars);
      const parsedStory = markdownToStory(markdown);

      expect(parsedStory.content).toContain('**bold**');
      expect(parsedStory.content).toContain('*italic*');
      expect(parsedStory.content).toContain('`code`');
      expect(parsedStory.summary).toContain('[links](http://example.com)');
      expect(parsedStory.summary).toContain('#hashtags');
    });
  });

  describe('createDefaultStory', () => {
    it('should create a story with default template content', () => {
      const story = createDefaultStory('My Project');

      expect(story.title).toBe('My Project');
      expect(story.id).toBeTruthy();
      expect(story.genre).toEqual([]);
      expect(story.tone).toEqual([]);
      expect(story.length).toBe('medium');
      expect(story.charactersUsed).toEqual([]);
      expect(story.locationsUsed).toEqual([]);
      expect(story.autoGeneratedElements).toEqual([]);
      expect(story.version).toBe(1);
      expect(story.createdAt).toBeInstanceOf(Date);
      expect(story.updatedAt).toBeInstanceOf(Date);
    });

    it('should include placeholder content', () => {
      const story = createDefaultStory('Test Project');

      expect(story.content).toContain('storyteller wizard');
      expect(story.summary).toContain('brief summary');
    });

    it('should generate unique IDs for different stories', () => {
      const story1 = createDefaultStory('Project 1');
      const story2 = createDefaultStory('Project 2');

      expect(story1.id).not.toBe(story2.id);
    });
  });

  describe('edge cases', () => {
    it('should handle very long content', () => {
      const longContent = 'A'.repeat(10000);
      const storyWithLongContent = {
        ...sampleStory,
        content: longContent,
      };

      const markdown = storyToMarkdown(storyWithLongContent);
      const parsedStory = markdownToStory(markdown);

      expect(parsedStory.content).toBe(longContent);
    });

    it('should handle content with multiple consecutive newlines', () => {
      const contentWithNewlines = 'Line 1\n\n\n\nLine 2';
      const storyWithNewlines = {
        ...sampleStory,
        content: contentWithNewlines,
      };

      const markdown = storyToMarkdown(storyWithNewlines);
      const parsedStory = markdownToStory(markdown);

      expect(parsedStory.content).toContain('Line 1');
      expect(parsedStory.content).toContain('Line 2');
    });

    it('should handle genre and tone with commas in values', () => {
      const markdown = `# Story

**Genre**: Science Fiction, Fantasy
**Tone**: Dark, Mysterious

## Main Content

Content`;

      const story = markdownToStory(markdown);

      expect(story.genre).toEqual(['Science Fiction', 'Fantasy']);
      expect(story.tone).toEqual(['Dark', 'Mysterious']);
    });

    it('should handle invalid length values', () => {
      const markdown = `# Story

**Length**: invalid

## Main Content

Content`;

      const story = markdownToStory(markdown);

      // Should keep default value when invalid
      expect(story.length).toBe('medium');
    });
  });
});
