// ============================================================================
// Story Types for Storyteller Wizard - LLM-Optimized
// ============================================================================

/**
 * Story file format type - unified to .md for LLM optimization
 */
export type StoryFileFormat = 'md';

/**
 * Story part types for iterative generation
 */
export type StoryPartType = 'intro' | 'chapter' | 'ending';

/**
 * Review scores for story quality assessment
 */
export interface ReviewScore {
  tension: number;   // 0-100
  drama: number;     // 0-100
  sense: number;     // 0-100 (coherence)
  emotion: number;   // 0-100
  overall: number;   // 0-100
}

/**
 * YAML frontmatter metadata for LLM-optimized story files
 */
export interface StoryFileMetadata {
  title: string;
  type: 'index' | StoryPartType | 'summary';
  order?: number;
  part_number?: number;
  total_parts?: number;
  genre?: string[];
  tone?: string[];
  characters?: string[];
  locations?: string[];
  previous_summary?: string;
  next_part?: string;
  prev_part?: string;
  generated_at?: string;
  review_score?: ReviewScore;
}

/**
 * A specific part of an iteratively generated story
 * Optimized for LLM context window management
 */
export interface StoryPart {
  id: string;
  type: StoryPartType;
  title: string;
  content: string;
  summary: string; // Rolling summary for next part context
  reviewScore?: ReviewScore;
  order: number;
  metadata?: StoryFileMetadata; // YAML frontmatter data
}

/**
 * Reference to a character used in a story
 */
export interface CharacterReference {
  id: string;
  name: string;
  role: string;
}

/**
 * Reference to a location used in a story
 */
export interface LocationReference {
  id: string;
  name: string;
  significance: string;
  type?: string;
}

/**
 * Auto-generated element (character or location) created during story generation
 */
export interface AutoGeneratedElement {
  type: 'character' | 'location';
  id: string;
  name: string;
  generatedAt: Date;
}

/**
 * Main Story interface representing a complete narrative
 */
export interface Story {
  id: string;
  title: string;
  content: string; // Combined content of all parts
  summary: string; // Final summary
  genre: string[];
  tone: string[];
  length: 'short' | 'medium' | 'long' | 'scene' | 'short_story' | 'novella' | 'novel' | 'epic_novel';
  charactersUsed: CharacterReference[];
  locationsUsed: LocationReference[];
  autoGeneratedElements: AutoGeneratedElement[];
  createdAt: Date;
  updatedAt: Date;
  version: number;
  worldId?: string;
  parts?: StoryPart[]; // For iterative, multi-part generation
  fileFormat?: StoryFileFormat; // Always 'md' in new system
}

/**
 * Draft version of a story (incomplete, saved for later)
 */
export interface StoryDraft {
  id: string;
  storyId: string;
  data: Partial<Story>;
  currentStep: number;
  savedAt: Date;
}

/**
 * Version snapshot of a story
 */
export interface StoryVersion {
  id: string;
  storyId: string;
  versionNumber: number;
  content: string;
  summary: string;
  createdAt: Date;
  changes: string;
}

/**
 * World context for story generation
 */
export interface WorldContext {
  id: string;
  name: string;
  genre: string[];
  tone: string[];
  rules: WorldRule[];
  culturalElements: CulturalElements;
  atmosphere: string;
}

/**
 * World rule definition
 */
export interface WorldRule {
  id: string;
  category: string;
  rule: string;
  description: string;
}

/**
 * Cultural elements of a world
 */
export interface CulturalElements {
  languages?: string[];
  religions?: string[];
  customs?: string[];
  traditions?: string[];
  socialStructure?: string;
}

/**
 * Parameters for story generation
 */
export interface StoryGenerationParams {
  genre: string[];
  tone: string[];
  length: 'short' | 'medium' | 'long' | 'scene' | 'short_story' | 'novella' | 'novel' | 'epic_novel';
  characters: { name: string; description?: string; role?: string;[key: string]: any }[]; // Character objects from world data
  locations: { name: string; description?: string; type?: string;[key: string]: any }[]; // Location objects from world data
  worldContext: WorldContext;
  totalTitle?: string;
}

/**
 * Progress tracking for story generation
 */
export interface GenerationProgress {
  stage:
  | 'preparing'
  | 'creating_elements'
  | 'generating_intro'
  | 'generating_chapter'
  | 'generating_ending'
  | 'reviewing'
  | 'refining'
  | 'complete';
  progress: number; // 0-100
  currentTask: string;
  currentChapter?: number;
  totalChapters?: number;
  error?: string;
}

/**
 * Request to create a new character
 */
export interface CharacterCreationRequest {
  name: string;
  role: string;
  description: string;
}

/**
 * Request to create a new location
 */
export interface LocationCreationRequest {
  name: string;
  type: string;
  description: string;
}

/**
 * Export options for story files
 */
export interface ExportOptions {
  format: StoryFileFormat;
  includeMetadata: boolean;
  includeSummary: boolean;
  filename: string;
}

/**
 * Story setup data (Step 1)
 */
export interface StorySetupData {
  genre: string[];
  tone: string[];
  length: 'short' | 'medium' | 'long' | 'scene' | 'short_story' | 'novella' | 'novel' | 'epic_novel';
  title?: string;
}

/**
 * Character selection data (Step 2)
 */
export interface CharacterSelectionData {
  selectedCharacters: CharacterReference[];
  newCharactersToCreate: CharacterCreationRequest[];
}

/**
 * Location selection data (Step 3)
 */
export interface LocationSelectionData {
  selectedLocations: LocationReference[];
  newLocationsToCreate: LocationCreationRequest[];
}

// ============================================================================
// Legacy Story Types (kept for backward compatibility)
// ============================================================================

export interface StorySummary {
  id: string;
  title: string;
  genre: string[];
  tone: string[];
  targetAudience: string;
  videoType: 'court-métrage' | 'métrage' | 'série-episode' | 'web-série';
  duration: number; // minutes
  acts: StoryAct[];
  keyCharacters: string[];
  mainConflict: string;
  resolution: string;
  themes: string[];
  selectedVisualStyle: string;
  recommendedVisualStyle: string;
  pacing: string;
  musicSuggestions?: string[];
  moodPalette?: string[];
  cameraTechniques?: string[];
  createdAt: Date;
  basedOnPreviousEpisode?: string;
  worldContext: string;
}

export interface StoryAct {
  id: string;
  number: number;
  title: string;
  description: string;
  keyScenes: string[];
  characterDevelopment: string;
  duration: number; // minutes
}

export interface StoryContext {
  characters: unknown[];
  world: unknown;
  locations: unknown[];
  previousEpisodes: unknown[];
  userPreferences: {
    preferredGenres: string[];
    preferredVideoType: string;
    preferredDuration: number;
    preferredTone: string[];
  };
}

export interface StorytellerWizardData {
  selectedCharacters: string[];
  selectedLocations: string[];
  previousEpisodeReference: string;
  videoType: 'court-métrage' | 'métrage' | 'série-episode' | 'web-série';
  targetDuration: number;
  genre: string[];
  tone: string[];
  targetAudience: string;
  visualStyle: string;
  storySummary: string;
  mainConflict: string;
  resolution: string;
  themes: string[];
  acts: StoryAct[];
  recommendedVisualStyle: string;
  pacing: string;
  musicSuggestions?: string[];
  moodPalette?: string[];
  cameraTechniques?: string[];
  isValidated: boolean;
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Create an empty story with default values
 */
export function createEmptyStory(): Partial<Story> {
  return {
    id: crypto.randomUUID(),
    title: '',
    content: '',
    summary: '',
    genre: [],
    tone: [],
    length: 'medium',
    charactersUsed: [],
    locationsUsed: [],
    autoGeneratedElements: [],
    createdAt: new Date(),
    updatedAt: new Date(),
    version: 1,
    fileFormat: 'md',
  };
}

/**
 * Check if a story is complete (has all required fields)
 */
export function isStoryComplete(story: Partial<Story>): story is Story {
  return !!(
    story.id &&
    story.title &&
    story.content &&
    story.summary &&
    story.genre &&
    story.genre.length > 0 &&
    story.tone &&
    story.tone.length > 0 &&
    story.length &&
    story.charactersUsed &&
    story.locationsUsed &&
    story.autoGeneratedElements !== undefined &&
    story.createdAt &&
    story.updatedAt &&
    story.version
  );
}

/**
 * Get the number of chapters based on story length
 */
export function getChapterCount(length: Story['length']): number {
  const counts: Record<Story['length'], number> = {
    scene: 0,
    short: 1,
    short_story: 2,
    medium: 3,
    novella: 5,
    long: 5,
    novel: 10,
    epic_novel: 15,
  };
  return counts[length] || 3;
}

/**
 * Get estimated word count for story length
 */
export function getEstimatedWordCount(length: Story['length']): string {
  const counts: Record<Story['length'], string> = {
    scene: '200-500',
    short: '500-1000',
    short_story: '1500-3000',
    medium: '2500-5000',
    novella: '10000-20000',
    long: '2500-5000',
    novel: '40000-60000',
    epic_novel: '80000-120000',
  };
  return counts[length] || '1000-2500';
}

// ============================================================================
// Re-export methodology types for convenience
// ============================================================================

export {
  StoryMethodologyType,
  StoryPhase,
  ApprovalStatus,
  WritingStyle,
  ConsistencyCheckIntensity,
  type MethodologyState,
  type PhaseState,
  type MethodologySettings,
  type StructuredDraftRefineOptions,
  type LinearProgressiveOptions,
  type IterativeChapterOptions,
  type MethodologyDescription,
  type MethodologyOption,
  type PhaseGenerationResult,
  type ConsistencyValidationResult,
  type StorySkeleton,
  type MasterOutline,
  type RevisionEntry,
  type CharacterArc,
  type SceneBreakdown,
} from './storyMethodology';


