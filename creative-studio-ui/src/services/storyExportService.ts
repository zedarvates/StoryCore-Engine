// ============================================================================
// Story Export Service
// ============================================================================
// This service handles exporting stories to file system in various formats:
// - Plain text (.txt)
// - Markdown (.md)
// - Includes metadata, summary, characters, and locations
// ============================================================================

import { Story, ExportOptions } from '../types/story';

// ============================================================================
// Export Service Interface
// ============================================================================

export interface StoryExportService {
  exportStory(story: Story, options: ExportOptions): Promise<string>;
  getExportPath(projectName: string, filename: string): string;
}

// ============================================================================
// Format Functions
// ============================================================================

/**
 * Format story as Markdown
 * @param story Story object
 * @param options Export options
 * @returns Formatted markdown string
 */
export function formatStoryAsMarkdown(
  story: Story,
  options: ExportOptions
): string {
  let markdown = '';

  // Title
  markdown += `# ${story.title}\n\n`;

  // Metadata section
  if (options.includeMetadata) {
    markdown += `**Genre:** ${story.genre.join(', ')}\n`;
    markdown += `**Tone:** ${story.tone.join(', ')}\n`;
    markdown += `**Length:** ${story.length}\n`;
    markdown += `**Created:** ${story.createdAt.toLocaleDateString()}\n`;
    markdown += `**Version:** ${story.version}\n\n`;
  }

  // Summary section
  if (options.includeSummary && story.summary) {
    markdown += `## Summary\n\n`;
    markdown += `${story.summary}\n\n`;
  }

  // Characters section
  if (story.charactersUsed.length > 0) {
    markdown += `## Characters\n\n`;
    story.charactersUsed.forEach((char) => {
      markdown += `- **${char.name}** - ${char.role}\n`;
    });
    markdown += `\n`;
  }

  // Locations section
  if (story.locationsUsed.length > 0) {
    markdown += `## Locations\n\n`;
    story.locationsUsed.forEach((loc) => {
      markdown += `- **${loc.name}** - ${loc.significance}\n`;
    });
    markdown += `\n`;
  }

  // Story content
  markdown += `## Story\n\n`;
  markdown += `${story.content}\n\n`;

  // Metadata footer
  if (options.includeMetadata) {
    markdown += `---\n\n`;
    markdown += `## Metadata\n\n`;
    
    if (story.worldId) {
      markdown += `**World:** ${story.worldId}\n`;
    }
    
    markdown += `**Characters Used:** ${story.charactersUsed.map(c => c.name).join(', ')}\n`;
    markdown += `**Locations Used:** ${story.locationsUsed.map(l => l.name).join(', ')}\n`;
    
    if (story.autoGeneratedElements.length > 0) {
      markdown += `**Auto-Generated Elements:** ${story.autoGeneratedElements.map(e => `${e.name} (${e.type})`).join(', ')}\n`;
    }
    
    markdown += `**Version:** ${story.version}\n`;
  }

  return markdown;
}

/**
 * Format story as plain text
 * @param story Story object
 * @param options Export options
 * @returns Formatted plain text string
 */
export function formatStoryAsText(
  story: Story,
  options: ExportOptions
): string {
  let text = '';

  // Title
  text += `${story.title}\n`;
  text += `${'='.repeat(story.title.length)}\n\n`;

  // Metadata section
  if (options.includeMetadata) {
    text += `Genre: ${story.genre.join(', ')}\n`;
    text += `Tone: ${story.tone.join(', ')}\n`;
    text += `Length: ${story.length}\n`;
    text += `Created: ${story.createdAt.toLocaleDateString()}\n`;
    text += `Version: ${story.version}\n\n`;
  }

  // Summary section
  if (options.includeSummary && story.summary) {
    text += `SUMMARY\n`;
    text += `-------\n`;
    text += `${story.summary}\n\n`;
  }

  // Characters section
  if (story.charactersUsed.length > 0) {
    text += `CHARACTERS\n`;
    text += `----------\n`;
    story.charactersUsed.forEach((char) => {
      text += `${char.name} - ${char.role}\n`;
    });
    text += `\n`;
  }

  // Locations section
  if (story.locationsUsed.length > 0) {
    text += `LOCATIONS\n`;
    text += `---------\n`;
    story.locationsUsed.forEach((loc) => {
      text += `${loc.name} - ${loc.significance}\n`;
    });
    text += `\n`;
  }

  // Story content
  text += `STORY\n`;
  text += `-----\n`;
  text += `${story.content}\n\n`;

  // Metadata footer
  if (options.includeMetadata) {
    text += `${'='.repeat(50)}\n\n`;
    text += `METADATA\n`;
    text += `--------\n`;
    
    if (story.worldId) {
      text += `World: ${story.worldId}\n`;
    }
    
    text += `Characters Used: ${story.charactersUsed.map(c => c.name).join(', ')}\n`;
    text += `Locations Used: ${story.locationsUsed.map(l => l.name).join(', ')}\n`;
    
    if (story.autoGeneratedElements.length > 0) {
      text += `Auto-Generated Elements: ${story.autoGeneratedElements.map(e => `${e.name} (${e.type})`).join(', ')}\n`;
    }
    
    text += `Version: ${story.version}\n`;
  }

  return text;
}

// ============================================================================
// Export Functions
// ============================================================================

/**
 * Export story to file system
 * @param story Story object
 * @param options Export options
 * @returns File path of exported story
 */
export async function exportStory(
  story: Story,
  options: ExportOptions
): Promise<string> {
  try {
    // 1. Format the story content based on the selected format
    const content = options.format === 'md'
      ? formatStoryAsMarkdown(story, options)
      : formatStoryAsText(story, options);

    // 2. Sanitize the filename
    const sanitizedFilename = sanitizeFilename(options.filename);
    
    // 3. Ensure the filename has the correct extension
    const filename = sanitizedFilename.endsWith(`.${options.format}`)
      ? sanitizedFilename
      : `${sanitizedFilename}.${options.format}`;

    // 4. Determine MIME type based on format
    const mimeType = options.format === 'md' ? 'text/markdown' : 'text/plain';

    // 5. Create a Blob with the content
    const blob = new Blob([content], { type: mimeType });

    // 6. Check if we're in Electron environment
    if (typeof window !== 'undefined' && (window as any).electron) {
      // Electron environment - use IPC to save file
      try {
        const { electron } = window as any;
        const projectName = story.worldId || 'default';
        const filePath = await electron.saveFile(filename, content, projectName);
        return filePath;
      } catch (electronError) {
        console.warn('Electron file save failed, falling back to browser download:', electronError);
        // Fall through to browser download
      }
    }

    // 7. Browser environment - trigger download
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.style.display = 'none';
    
    // Append to body, click, and remove
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up the URL object
    setTimeout(() => URL.revokeObjectURL(url), 100);

    // Return the filename as the "path" for browser downloads
    return filename;
  } catch (error) {
    // Handle errors with descriptive messages
    const errorMessage = handleExportError(error);
    throw new Error(errorMessage);
  }
}

/**
 * Get export path for a story file
 * @param projectName Project name
 * @param filename Filename
 * @returns Full file path
 */
export function getExportPath(projectName: string, filename: string): string {
  // Sanitize inputs
  const sanitizedProject = sanitizeFilename(projectName);
  const sanitizedFilename = sanitizeFilename(filename);
  
  // Check if we're in Electron environment
  if (typeof window !== 'undefined' && (window as any).electron) {
    // Electron environment - construct full path
    // The actual path will be determined by the main process
    return `projects/${sanitizedProject}/stories/${sanitizedFilename}`;
  }
  
  // Browser environment - return just the filename
  // (downloads go to the browser's default download location)
  return sanitizedFilename;
}

// ============================================================================
// Error Handling
// ============================================================================

/**
 * Handle file system errors during export
 * @param error Error object
 * @returns User-friendly error message
 */
export function handleExportError(error: unknown): string {
  if (error.message?.includes('permission')) {
    return 'Permission denied: Unable to write to the export directory. Please check file permissions.';
  }
  
  if (error.message?.includes('disk space')) {
    return 'Insufficient disk space: Unable to save the file. Please free up some space.';
  }
  
  if (error.message?.includes('path')) {
    return 'Invalid path: The export directory does not exist or is invalid.';
  }
  
  return `Export error: ${error.message || 'Unknown error occurred'}`;
}

/**
 * Sanitize filename to remove invalid characters
 * @param filename Original filename
 * @returns Sanitized filename
 */
export function sanitizeFilename(filename: string): string {
  // Remove invalid characters for file systems
  return filename
    .replace(/[<>:"/\\|?*]/g, '')
    .replace(/\s+/g, '_')
    .substring(0, 255); // Max filename length
}

/**
 * Generate default filename for a story
 * @param story Story object
 * @param format Export format
 * @returns Default filename
 */
export function generateDefaultFilename(
  story: Story,
  format: 'txt' | 'md'
): string {
  const sanitizedTitle = sanitizeFilename(story.title || 'untitled');
  const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  return `${sanitizedTitle}_${timestamp}.${format}`;
}

