/**
 * Story Export Service Tests
 * 
 * Tests for the story export service functions
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import {
  exportStory,
  formatStoryAsMarkdown,
  formatStoryAsText,
  getExportPath,
  sanitizeFilename,
  generateDefaultFilename,
} from '../storyExportService';
import type { Story, ExportOptions } from '../../types/story';

// Mock story data
const mockStory: Story = {
  id: 'story-1',
  title: 'The Crystal Quest',
  content: 'Once upon a time in a magical kingdom, a brave hero named Aria set out on a quest to find the legendary Crystal of Power...',
  summary: 'A brave hero embarks on a quest to find a legendary crystal and save the kingdom.',
  genre: ['fantasy', 'adventure'],
  tone: ['epic', 'mysterious'],
  length: 'medium',
  charactersUsed: [
    { id: 'char-1', name: 'Aria', role: 'Hero' },
    { id: 'char-2', name: 'Zara', role: 'Mentor' },
  ],
  locationsUsed: [
    { id: 'loc-1', name: 'Crystal Castle', significance: 'The seat of power' },
    { id: 'loc-2', name: 'Dark Forest', significance: 'A dangerous path' },
  ],
  autoGeneratedElements: [
    { type: 'character', id: 'char-3', name: 'Shadow King', generatedAt: new Date() },
  ],
  createdAt: new Date('2024-01-15'),
  updatedAt: new Date('2024-01-15'),
  version: 1,
  worldId: 'world-1',
};

describe('Story Export Service', () => {
  describe('formatStoryAsMarkdown', () => {
    it('should format story as markdown with all sections', () => {
      const options: ExportOptions = {
        format: 'md',
        includeMetadata: true,
        includeSummary: true,
        filename: 'test.md',
      };

      const result = formatStoryAsMarkdown(mockStory, options);

      expect(result).toContain('# The Crystal Quest');
      expect(result).toContain('**Genre:** fantasy, adventure');
      expect(result).toContain('**Tone:** epic, mysterious');
      expect(result).toContain('## Summary');
      expect(result).toContain('A brave hero embarks');
      expect(result).toContain('## Characters');
      expect(result).toContain('- **Aria** - Hero');
      expect(result).toContain('## Locations');
      expect(result).toContain('- **Crystal Castle** - The seat of power');
      expect(result).toContain('## Story');
      expect(result).toContain('Once upon a time');
      expect(result).toContain('## Metadata');
      expect(result).toContain('**Auto-Generated Elements:** Shadow King (character)');
    });

    it('should exclude metadata when includeMetadata is false', () => {
      const options: ExportOptions = {
        format: 'md',
        includeMetadata: false,
        includeSummary: true,
        filename: 'test.md',
      };

      const result = formatStoryAsMarkdown(mockStory, options);

      expect(result).not.toContain('**Genre:**');
      expect(result).not.toContain('## Metadata');
      expect(result).toContain('# The Crystal Quest');
      expect(result).toContain('## Summary');
    });

    it('should exclude summary when includeSummary is false', () => {
      const options: ExportOptions = {
        format: 'md',
        includeMetadata: true,
        includeSummary: false,
        filename: 'test.md',
      };

      const result = formatStoryAsMarkdown(mockStory, options);

      expect(result).not.toContain('## Summary');
      expect(result).toContain('# The Crystal Quest');
      expect(result).toContain('## Characters');
    });
  });

  describe('formatStoryAsText', () => {
    it('should format story as plain text with all sections', () => {
      const options: ExportOptions = {
        format: 'txt',
        includeMetadata: true,
        includeSummary: true,
        filename: 'test.txt',
      };

      const result = formatStoryAsText(mockStory, options);

      expect(result).toContain('The Crystal Quest');
      expect(result).toContain('='.repeat('The Crystal Quest'.length));
      expect(result).toContain('Genre: fantasy, adventure');
      expect(result).toContain('Tone: epic, mysterious');
      expect(result).toContain('SUMMARY');
      expect(result).toContain('-------');
      expect(result).toContain('CHARACTERS');
      expect(result).toContain('Aria - Hero');
      expect(result).toContain('LOCATIONS');
      expect(result).toContain('Crystal Castle - The seat of power');
      expect(result).toContain('STORY');
      expect(result).toContain('Once upon a time');
      expect(result).toContain('METADATA');
      expect(result).toContain('Auto-Generated Elements: Shadow King (character)');
    });

    it('should exclude metadata when includeMetadata is false', () => {
      const options: ExportOptions = {
        format: 'txt',
        includeMetadata: false,
        includeSummary: true,
        filename: 'test.txt',
      };

      const result = formatStoryAsText(mockStory, options);

      expect(result).not.toContain('Genre:');
      expect(result).not.toContain('METADATA');
      expect(result).toContain('The Crystal Quest');
      expect(result).toContain('SUMMARY');
    });

    it('should exclude summary when includeSummary is false', () => {
      const options: ExportOptions = {
        format: 'txt',
        includeMetadata: true,
        includeSummary: false,
        filename: 'test.txt',
      };

      const result = formatStoryAsText(mockStory, options);

      expect(result).not.toContain('SUMMARY');
      expect(result).toContain('The Crystal Quest');
      expect(result).toContain('CHARACTERS');
    });
  });

  describe('exportStory', () => {
    let createElementSpy: any;
    let appendChildSpy: any;
    let removeChildSpy: any;
    let clickSpy: any;
    let createObjectURLSpy: any;
    let revokeObjectURLSpy: any;

    beforeEach(() => {
      // Mock URL methods if they don't exist
      if (!global.URL.createObjectURL) {
        global.URL.createObjectURL = vi.fn();
      }
      if (!global.URL.revokeObjectURL) {
        global.URL.revokeObjectURL = vi.fn();
      }

      // Mock DOM methods
      createElementSpy = vi.spyOn(document, 'createElement');
      appendChildSpy = vi.spyOn(document.body, 'appendChild');
      removeChildSpy = vi.spyOn(document.body, 'removeChild');
      clickSpy = vi.fn();
      createObjectURLSpy = vi.spyOn(global.URL, 'createObjectURL').mockReturnValue('blob:mock-url');
      revokeObjectURLSpy = vi.spyOn(global.URL, 'revokeObjectURL').mockImplementation(() => {});

      // Mock link element
      const mockLink = {
        href: '',
        download: '',
        style: { display: '' },
        click: clickSpy,
      };
      createElementSpy.mockReturnValue(mockLink as any);
      appendChildSpy.mockImplementation(() => mockLink as any);
      removeChildSpy.mockImplementation(() => mockLink as any);
    });

    afterEach(() => {
      vi.restoreAllMocks();
    });

    it('should export story as markdown in browser environment', async () => {
      const options: ExportOptions = {
        format: 'md',
        includeMetadata: true,
        includeSummary: true,
        filename: 'my-story.md',
      };

      const result = await exportStory(mockStory, options);

      expect(result).toBe('my-story.md');
      expect(createObjectURLSpy).toHaveBeenCalled();
      expect(createElementSpy).toHaveBeenCalledWith('a');
      expect(clickSpy).toHaveBeenCalled();
      expect(appendChildSpy).toHaveBeenCalled();
      expect(removeChildSpy).toHaveBeenCalled();
    });

    it('should export story as text in browser environment', async () => {
      const options: ExportOptions = {
        format: 'txt',
        includeMetadata: true,
        includeSummary: true,
        filename: 'my-story.txt',
      };

      const result = await exportStory(mockStory, options);

      expect(result).toBe('my-story.txt');
      expect(createObjectURLSpy).toHaveBeenCalled();
      expect(clickSpy).toHaveBeenCalled();
    });

    it('should add extension if missing', async () => {
      const options: ExportOptions = {
        format: 'md',
        includeMetadata: true,
        includeSummary: true,
        filename: 'my-story',
      };

      const result = await exportStory(mockStory, options);

      expect(result).toBe('my-story.md');
    });

    it('should sanitize filename', async () => {
      const options: ExportOptions = {
        format: 'md',
        includeMetadata: true,
        includeSummary: true,
        filename: 'my<story>with:invalid*chars.md',
      };

      const result = await exportStory(mockStory, options);

      expect(result).toBe('mystorywithinvalidchars.md');
    });

    it('should clean up URL after export', async () => {
      const options: ExportOptions = {
        format: 'md',
        includeMetadata: true,
        includeSummary: true,
        filename: 'test.md',
      };

      await exportStory(mockStory, options);

      // Wait for setTimeout to execute
      await new Promise(resolve => setTimeout(resolve, 150));

      expect(revokeObjectURLSpy).toHaveBeenCalledWith('blob:mock-url');
    });
  });

  describe('getExportPath', () => {
    it('should return sanitized filename in browser environment', () => {
      const result = getExportPath('my-project', 'my-story.md');

      expect(result).toBe('my-story.md');
    });

    it('should sanitize project name and filename', () => {
      const result = getExportPath('my<project>', 'my:story*.md');

      expect(result).toBe('mystory.md');
    });

    it('should construct path for Electron environment', () => {
      // Mock Electron environment
      (global as any).window = { electron: {} };

      const result = getExportPath('my-project', 'my-story.md');

      expect(result).toContain('projects/my-project/stories/my-story.md');

      // Clean up
      delete (global as any).window;
    });
  });

  describe('sanitizeFilename', () => {
    it('should remove invalid characters', () => {
      const result = sanitizeFilename('file<name>with:invalid*chars?.txt');

      expect(result).toBe('filenamewithinvalidchars.txt');
    });

    it('should replace spaces with underscores', () => {
      const result = sanitizeFilename('my story file.txt');

      expect(result).toBe('my_story_file.txt');
    });

    it('should truncate long filenames', () => {
      const longName = 'a'.repeat(300) + '.txt';
      const result = sanitizeFilename(longName);

      expect(result.length).toBeLessThanOrEqual(255);
    });

    it('should handle empty string', () => {
      const result = sanitizeFilename('');

      expect(result).toBe('');
    });
  });

  describe('generateDefaultFilename', () => {
    it('should generate filename with title and date for markdown', () => {
      const result = generateDefaultFilename(mockStory, 'md');

      expect(result).toMatch(/^The_Crystal_Quest_\d{4}-\d{2}-\d{2}\.md$/);
    });

    it('should generate filename with title and date for text', () => {
      const result = generateDefaultFilename(mockStory, 'txt');

      expect(result).toMatch(/^The_Crystal_Quest_\d{4}-\d{2}-\d{2}\.txt$/);
    });

    it('should use "untitled" for stories without title', () => {
      const storyWithoutTitle = { ...mockStory, title: '' };
      const result = generateDefaultFilename(storyWithoutTitle, 'md');

      expect(result).toMatch(/^untitled_\d{4}-\d{2}-\d{2}\.md$/);
    });

    it('should sanitize title in filename', () => {
      const storyWithInvalidTitle = { ...mockStory, title: 'My<Story>:With*Invalid?Chars' };
      const result = generateDefaultFilename(storyWithInvalidTitle, 'md');

      expect(result).toMatch(/^MyStoryWithInvalidChars_\d{4}-\d{2}-\d{2}\.md$/);
    });
  });
});

